{"meta":{"title":"Punmy","subtitle":"Codes, thoughts and stories","description":"潘名扬的博客","author":"Nico","url":"http://punmy.cn"},"pages":[{"title":"Tags","date":"2018-04-07T09:24:36.336Z","updated":"2017-07-31T15:43:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://punmy.cn/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2018-04-07T09:24:36.315Z","updated":"2017-07-31T15:43:13.000Z","comments":true,"path":"about/index.html","permalink":"http://punmy.cn/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-04-07T09:24:36.326Z","updated":"2017-07-31T15:43:13.000Z","comments":true,"path":"categories/index.html","permalink":"http://punmy.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP/2 初探","slug":"15041894895980","date":"2017-08-31T14:24:00.000Z","updated":"2017-10-25T16:31:01.000Z","comments":true,"path":"2017/08/31/15041894895980/","link":"","permalink":"http://punmy.cn/2017/08/31/15041894895980/","excerpt":"HTTP/2 是一个比它的几个前任更快、更简单、更稳定的 HTTP 协议。在 HTTP/2 中，我们可以摒弃掉很多以往针对 HTTP/1.1 想出来的“歪招儿”，因为它们的解决方案都内置在了传输层中。不仅如此，它还为我们进一步优化应用和提升性能提供全新的机会！","text":"HTTP/2 是一个比它的几个前任更快、更简单、更稳定的 HTTP 协议。在 HTTP/2 中，我们可以摒弃掉很多以往针对 HTTP/1.1 想出来的“歪招儿”，因为它们的解决方案都内置在了传输层中。不仅如此，它还为我们进一步优化应用和提升性能提供全新的机会！ 从 SPDY 到 HTTP/2SPDY 是 Google 在 2009 年发布的一个实验性协议，它是一个应用层的网络传输协议，也是 HTTP/2 的前身。SPDY 并不是为替代 HTTP 而生，它的目的是通过多路复用、请求优化和 HTTP 头部压缩等功能，来最小化 HTTP/1.1 的各种性能限制所导致的延迟。具体来说，这个项目设定的目标如下： 页面加载时间 (PLT) 减少 50%。 无需网站作者修改任何内容。 将部署复杂性降至最低，无需变更网络基础设施。 与开源社区合作开发这个新协议。 收集真实性能数据，验证这个实验性协议是否有效。 首次发布后不久，Google 分享了 SPDY 协议的实现结果、文档和源代码，宣布在实验室条件下取得了 55% 的速度提升。 几年后的 2012 年，这个新的实验性协议得到了 Chrome、Firefox 和 Opera 的支持，越来越多的网站开始在部署 SPDY。事实上，在行业中被越来越多地采用之后，SPDY 已经具备了成为一个标准的条件。 观察到这一趋势后，HTTP 工作组将这一工作提上议事日程，吸取 SPDY 的经验教训，并在此基础上制定了官方“HTTP/2”标准。在拟定草案、向社会征集 HTTP/2 建议并经过内部讨论之后，HTTP 工作组决定将 SPDY 规范作为新 HTTP/2 协议的基础。 在接下来几年中，SPDY 和 HTTP/2 继续共同演化，SPDY 作为实验性分支，为 HTTP/2 标准测试新功能和建议，对要包含到 HTTP/2 标准中的每条建议进行测试和评估。最终，这个过程持续了三年，期间产生了十余个中间草案。 最终，在2015 年初，IETF 审阅了新的 HTTP/2 标准并批准发布。SPDY 与 HTTP/2 的共同演化使得它在诞生之日就已经是一个经过大量实践的标准，发布后不久，就得到了广泛应用。 为何选择 HTTP/2HTTP/1.x 的问题想了解 HTTP/2 的优势，就得从 HTTP/1.x 存在的问题说起。 HTTP/1.x 中存在许多问题使得它越来越难以满足快速发展的互联网。 其中，HTTP/1.x 最大的问题就是一个连接同时只能处理一个请求。这意味着同一个连接下发起的多个请求只能逐个请求和接收。同时，由于没有优先级管理，HTTP/1.x 同一个连接中的多个请求只能采取 FIFO 的方式，依次完成。如果连接被某个耗时长的请求占用，那么其它所有请求就只能排队等候，直到收到回复或者超时。这就是所谓的队头阻塞（Head-of-Line Blocking，HOLB）。 这个问题的一个解决方案就是 HTTP pipelining。通过 HTTP pipelining，在同一个连接上，可以不等队伍前方的请求收到响应，就先行发送后续的请求。这样一来请求就不会有延迟，使得服务器可以提早开始处理请求，一些耗时长的，如涉及数据库查询的请求，就可以提早进行，理论上可以提高 HTTP 的效率。 然而，响应还是需要逐个排队接收，所以它并不是真正的多路复用，但至少是个不错的提升了（如果它按照理论运行的话）。在 pipelining 开启后，HOLB 依旧存在，因为 response 仍然是逐个接收的。甚至和之前比起来，使用 pipelining 后，HOLB 更明显了。此外，由于 pipelining 实现起来复杂度比较高，在实践中还常常出现各种错误，所以它并没有被广泛推广。事实上，大多数主流的浏览器都禁用了 pipelining。 另一个解决方案就是对同一个 host 同时开启多个 HTTP 连接，这样就可以并行请求和接收，能够更快地获取到多个资源。但这仍然存在一些问题，例如建立连接产生的资源损耗等。并且同个域名存在最大连接数，所以为了提高连接数，一些网站只好将网页上的资源部署到不同的域名下。除此之外，由于 TCP 的拥塞控制使得 TCP 连接在建立后有一个缓启动的过程，所以多连接的方案实际上贡献的性能提升并没有想象中那么多。 此外，HTTP/1.x 还存在文本协议开销大、缺乏首部压缩等问题。综合这些来看，HTTP/1.x 只意味着更高的系统需求，和更低的性能表现。 HTTP/2 的改进二进制分帧层HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。二进制分帧层指的是位于传输层与应用层的高级 HTTP API 之间一个新编码机制。HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。 简言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。这是 HTTP/2 协议所有其他功能和性能优化的基础。 由于编码方式的不同，HTTP/2 无法向下兼容，这也是 HTTP/2 的版本号是 2 而不是 1.2 的主要原因。 连接复用在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接。但 HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。这是 HTTP 2 最重要的一项增强。 HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。最终使得应用速度更快、开发更简单、部署成本更低。 值得注意的是，HTTP/2 解决了 HTTP 的 HOL 阻塞，但并没有解决 TCP 上的 HOL 阻塞。 数据流优先级将 HTTP 消息分解为很多独立的帧之后，客户端和服务器交错传输这些帧的顺序，就成为关键的性能决定因素。为了做到这一点，HTTP/2 允许每个数据流都有一个优先级和依赖关系。数据流依赖关系和权重的组合使得服务器可以使用此信息控制 CPU、内存和其他资源的分配，确保将高优先级响应以最优方式传输至客户端。 数据流依赖关系和权重表示传输优先级，而不是要求，因此不能保证特定的处理或传输顺序。即，客户端无法强制服务器通过数据流优先级以特定顺序处理数据流。 单一连接有了新的分帧机制后，HTTP/2 不再依赖多个 TCP 连接去并行复用数据流；每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。因此，所有 HTTP/2 连接都是持久的，而且每个来源仅需要一个连接，随之带来诸多性能优势。 大多数 HTTP 传输都是短暂且急促的，而 TCP 则针对长时间的批量数据传输进行了优化。 通过重用相同的连接，HTTP/2 既可以更有效地利用每个 TCP 连接，也可以显著降低整体协议开销。不仅如此，使用更少的连接还可以减少占用的内存和处理空间。这降低了整体运行成本并提高了网络利用率和容量。 标头压缩每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，标头中的数据始终以纯文本形式发送，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应中的标头数据，这种格式采用两种简单但是强大的技术： 这种格式支持通过静态 Huffman 编码对传输的标头字段进行编码，从而减小了各个传输的大小。 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表，此列表随后会用作参考，对之前传输的值进行有效编码。 作为一种进一步优化方式，HPACK 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段的列表；动态表最初为空，将根据在特定连接内改变的值进行更新。 流控制流控制是一种阻止发送方向接收方发送大量数据的机制。这很容易让人联想到 TCP 流控制，它们所要解决的问题很相似。不过，由于 HTTP/2 数据流在一个 TCP 连接内复用，TCP 流控制既不够精细，也无法提供必要的应用级 API 来调节各个数据流的传输。为了解决这一问题，HTTP/2 提供了一组简单的构建块，允许客户端和服务器实现其自己的流控制。 例如，HTTP2 的流控制允许浏览器仅提取一部分特定资源，通过将流控制窗口减小为零来暂停提取，稍后再行恢复。换句话说，它允许浏览器提取图像预览，进行显示并允许其他高优先级数据流继续传输，然后在更关键的资源完成加载后恢复提取。 服务端推送HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。之所以要提供这个服务，是因为一个文档被请求回来时，往往还需要再次请求很多文档内的其他资源，如果这些资源的请求不用客户端发起，而是服务端提前预判发给客户端，那么就会减少大量时延。 HTTP2 协议也没有规定服务器端到底该怎样推送这个资源。服务端可以自己制定不同的策略，可以是根据客户端明确写出的推送请求；或者是服务端通过学习得来；再或者是通过额外的HTTP首部想服务端表明意向。 这个服务的特点是： 只有建立连接后，服务器才可以推送资源(发送 PUSH_PROMISE 帧)，也就是说服务器不能无缘无故的主动向客户端推送资源。 客户端可以发送 RST_STREAM 拒绝服务器推送来的资源。 推送的资源可以由不同页面共享 服务器可以按照优先级来推送资源 iOS 对 HTTP/2 的支持在 iOS 上，NSURLSession 提供了对 HTTP/2 的支持。只要服务器支持 HTTP/2，系统就会自动使用它，否则将自动选择 HTTP/1.1 或其它可用协议。 需要注意的是，iOS 只支持加密连接的 HTTP/2 协议，HTTP/2 服务器需要支持 ALPN 或者 NPN 加密连接。 移动客户端网络部分的不少初步优化还比较依赖于 HTTP/2 的推进。MTHawkeye 中已经加入了对 HTTP/2 的检测，大家平时在开发的过程中，可以关注下，是否有可能将现存的 HTTP/1.x 升级到 HTTP/2。 延伸阅读 HTTP/2 简介 Brief History of HTTP Google 公布 HTTP/2 的博客 WWDC 711 HTTP pipelining ALPN 和 NPN 简介 QUIC 文档","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"HTTP2","slug":"HTTP2","permalink":"http://punmy.cn/tags/HTTP2/"},{"name":"基础","slug":"基础","permalink":"http://punmy.cn/tags/基础/"},{"name":"网络","slug":"网络","permalink":"http://punmy.cn/tags/网络/"},{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"}]},{"title":"五分钟重拾正则表达式","slug":"15018607710939","date":"2017-08-04T15:01:00.000Z","updated":"2017-10-25T16:11:37.000Z","comments":true,"path":"2017/08/04/15018607710939/","link":"","permalink":"http://punmy.cn/2017/08/04/15018607710939/","excerpt":"什么是正则表达式正则表达式（Regular Expression，常简写为Regex）是一种表示文本规则的代码。在编写处理字符串的程序时，经常会有查找、替换符合某些规则的字符串的需要，正则表达式就是用于描述这些规则的工具。","text":"什么是正则表达式正则表达式（Regular Expression，常简写为Regex）是一种表示文本规则的代码。在编写处理字符串的程序时，经常会有查找、替换符合某些规则的字符串的需要，正则表达式就是用于描述这些规则的工具。 大多数人都在电脑上使用过用于文件查找的通配符，例如用“*.png”来查找所有的PNG格式的文件。正则表达式和通配符类似，也是用来进行文本匹配的工具。只是比起通配符，它能进行更精确的匹配，同时，也更为复杂。 正则表达式事实上是一种轻量级、简洁的编程语言，几乎所有的高级编程语言都支持正则表达式（语法不一定完全相同）。此外，大部分的代码编辑器，如 Sublime、VS Code 也都支持正则表达式的查找替换。因此，在学习正则表达式的时候，可以在 Sublime 之类的编辑器中进行尝试。 注：文件通配符与正则表达式无关。 基础语法字符正则表达式的语法中有普通字符和一些被称为“元字符”的特殊字符。 包括所有字母和数字字符在内的大部分字符，都是普通字符。普通字符只能匹配它们本身，如正则表达式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859只能匹配 ios 这个字符串（区分大小写）。下表是元字符及其行为的一个完整列表（转自维基百科。不是唯一的，不同的解析引擎可能略有不同）。| 字符 | 描述 || --- | --- || \\ | 将下一个字符标记为一个特殊字符（File Format Escape）、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\\\”匹配“\\”而“\\(”则匹配“(”。 || \\^ | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，\\^也匹配“\\n”或“\\r”之后的位置。 || $ | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 || * | 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于&#123;0,&#125;。 || + | 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于&#123;1,&#125;。 || ? | 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于&#123;0,1&#125;。 || &#123;n&#125; | n是一个非负整数。匹配确定的n次。例如，“o&#123;2&#125;”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 || &#123;n,&#125; | n是一个非负整数。至少匹配n次。例如，“o&#123;2,&#125;”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o&#123;1,&#125;”等价于“o+”。“o&#123;0,&#125;”则等价于“o*”。 || &#123;n,m&#125; | m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o&#123;1,3&#125;”将匹配“fooooood”中的前三个o。“o&#123;0,1&#125;”等价于“o?”。请注意在逗号和两个数之间不能有空格。 || ? | 非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，&#123;n&#125;，&#123;n,&#125;，&#123;n,m&#125;）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 || . | 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.|\\n)”的模式。 || (pattern) | 匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 || (?:pattern) | 匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 || (?=pattern) | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 || (?!pattern) | 正向否定预查（negative assert），在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 || (?&lt;=pattern) | 反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 || (?&lt;!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 || x|y | 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(?:z|f)ood”则匹配“zood”或“food”。 || [xyz] | 字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。特殊字符仅有反斜线\\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符\\^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。 || [\\^xyz] | 排除型字符集合（negated character classes）。匹配未列出的任意字符。例如，“[\\^abc]”可以匹配“plain”中的“plin”。 || [a-z] | 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 || [\\^a-z] | 排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[\\^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 || [:name:] | 增加命名字符类（named character class）[注 1]中的字符到表达式。只能用于方括号表达式。 || [=elt=] | 增加当前locale下排序（collate）等价于字符“elt”的元素。例如，[=a=]可能会增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ。只能用于方括号表达式。 || [.elt.] | 增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成。例如，29个字母表的西班牙语，&quot;CH&quot;作为单个字母排在字母C之后，因此会产生如此排序“cinco, credo, chispa”。只能用于方括号表达式。 || \\b | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 || \\B | 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 || \\cx | 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 || \\d | 匹配一个数字字符。等价于[0-9]。 || \\D | 匹配一个非数字字符。等价于[\\^0-9]。 || \\f | 匹配一个换页符。等价于\\x0c和\\cL。 || \\n | 匹配一个换行符。等价于\\x0a和\\cJ。 || \\r | 匹配一个回车符。等价于\\x0d和\\cM。 || \\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 || \\S | 匹配任何非空白字符。等价于[\\^ \\f\\n\\r\\t\\v]。 || \\t | 匹配一个制表符。等价于\\x09和\\cI。 || \\v | 匹配一个垂直制表符。等价于\\x0b和\\cK。 || \\w | 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 || \\W | 匹配任何非单词字符。等价于“[\\^A-Za-z0-9_]”。 || \\ck | 匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法。 || \\xnn | 十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。. || \\num | 向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\\1”匹配两个连续的相同字符。 || \\n | 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 || \\nm | 3位八进制数字，标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 || \\nml | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 || \\un | Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 |### 转义当需要匹配元字符本身的时候，为元字符加上“ \\ ”转义即可。### 匹配字符集合方括号“ [ ] ”用于表示要匹配的字符所属的字符集合。可以将所有可能匹配到的字符枚举出来，如：```[ios789] 可以匹配到 i 或者 o 或者 s 或者 7 或者 8 或者 9 。 也可以根据 ASCII码的顺序，将某个范围内的字符都包括在内，如上述的正则表达式等价于：123同时也能够在其中使用元字符，如：```[\\w,\\n] 可以匹配一个单词字符，或者一个逗号，或者一个换行符。 上述三个例子中，一次都只能匹配一个字符，如果要匹配多个字符，可以后接数量的修饰，如：12表示匹配两个或者三个字母；```[a-zA-Z]+ 表示匹配至少一个字母； 此外，也可以用1```[^0-9] 表示匹配一个数字以外的所有字符。 匹配定位点定位点能够将正则表达式固定到一行或整个字符串的起始位置或结尾。它们还能够创建匹配一个单词的开头、结尾或内部字符的表达式。 需要注意的是，定位点匹配到的并不是一个实际的字符，而只是一个位置。 例如，在表达式匹配单词边界。 该表达式与 “never” 中的 “er” 匹配，但与 “verb” 中的 “er” 不匹配。12345678910111213141516171819下表包含正则表达式定位点以及它们的含义：| 字符 | 说明 || --- | --- || ^ | 匹配输入字符串开始的位置。 如果标志中包括 m（多行搜索）字符，^ 还将匹配 \\n 或 \\r 后面的位置。 || $ | 匹配输入字符串结尾的位置。 如果标志中包括 m（多行搜索）字符，$ 还将匹配 \\n 或 \\r 前面的位置。 || \\b | 匹配一个字边界，即字与空格间的位置。 || \\B | 非字边界匹配。|### 子串的捕获使用括号可以捕获其中的子串，并将其保存作为变量，以用于后续的匹配或替换。假设正则表达式是一个小型计算机程序，那么捕获子串就是它输出的一部分。在实际使用中，可能会捕获很多子串，被捕获的子串从左向右编号，也就是只需要对左括号计数。引用时使用```\\x```的格式，子串编号从```\\1```开始，```\\0```表示原字符串本身。假设正则表达式如下： (\\w+) had a ((\\w+) \\w+)12那么对于字符串： I had a nice day12该正则表达式捕获到的子串如下： \\0: I had a nice day\\1: I\\2: nice\\3: nice day123456### 或正则表达式中允许对多个匹配选项之间进行分组，相当于“或”的作用。如正则表达式：```(Chapter|Section) [1-9][0-9]&#123;0,1&#125; 在匹配字符串：3 Section 90```1时，可以匹配到 ```Chapter``` 和 ```Section Objective-C 中的正则表达式Objective-C 中有专门的一个正则表达式类 —— NSRegularExpression，使用较为方便。此外在 NSPredicate 中也支持用正则表达式进行查询。OC 头文件中的注释对它们的具体用法作了详细的介绍，本文就再赘述了。 值得注意的是，OC 中的正则表达式中，匹配到的子串是用123456## 示例### 将表格替换为 Markdown 格式上文中从维基百科上拷贝下来的表格: 字符 描述\\ 将下一个字符标记为一个特殊字符（File Format Escape）、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\”匹配“\\”而“(”则匹配“(”。^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。$ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 匹配前面的子表达式零次或多次。例如，zo能匹配“z”、“zo”以及“zoo”。等价于{0,}。 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。12Markdown 格式的表格: 字符 描述 \\ 将下一个字符标记为一个特殊字符（File Format Escape）、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\”匹配“\\”而“(”则匹配“(”。 \\^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，\\^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”、“zo”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 123匹配的正则表达式：``` ^(.*?)\\t(.*)$ 替换的正则表达式：\\1 | \\2 | ```12345678910111213141516171819202122232425262728293031323334### 美拍滤镜 plist 格式替换原格式：```xml&lt;dict&gt; &lt;key&gt;id&lt;/key&gt; &lt;integer&gt;3002&lt;/integer&gt; &lt;key&gt;inputSource&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;index&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;source&lt;/key&gt; &lt;string&gt;3002/gleam.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;晨露&lt;/string&gt; &lt;key&gt;nameEN&lt;/key&gt; &lt;string&gt;Shimmer&lt;/string&gt; &lt;key&gt;nameTW&lt;/key&gt; &lt;string&gt;微光&lt;/string&gt; &lt;key&gt;percent&lt;/key&gt; &lt;real&gt;0.7&lt;/real&gt; &lt;key&gt;shaderType&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;statisticsId&lt;/key&gt; &lt;string&gt;fli3002&lt;/string&gt; &lt;key&gt;thumb&lt;/key&gt; &lt;string&gt;gleam2.png&lt;/string&gt;&lt;/dict&gt; 目标格式: 12345678910111213141516171819&lt;dict&gt; &lt;key&gt;ColorFilter&lt;/key&gt; &lt;integer&gt;58&lt;/integer&gt; &lt;key&gt;ColorFilterConfigPath&lt;/key&gt; &lt;string&gt;preFilters/3030/filterConfig.plist&lt;/string&gt; &lt;key&gt;Icon&lt;/key&gt; &lt;string&gt;perfume2.png&lt;/string&gt; &lt;key&gt;MVID&lt;/key&gt; &lt;string&gt;fli3030&lt;/string&gt; &lt;key&gt;Title&lt;/key&gt; &lt;string&gt;嘉年华&lt;/string&gt; &lt;key&gt;TitleTranslation&lt;/key&gt; &lt;dict&gt; &lt;key&gt;zh-Hant&lt;/key&gt; &lt;string&gt;嘉年華&lt;/string&gt; &lt;key&gt;en&lt;/key&gt; &lt;string&gt;Carnival&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt; 查找的正则表达式：1&lt;dict&gt;[\\w|\\W]*?&lt;key&gt;name&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;\\W+&lt;key&gt;nameEN&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;\\W+&lt;key&gt;nameTW&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;[\\w|\\W]*?&lt;key&gt;statisticsId&lt;/key&gt;\\W+&lt;string&gt;([a-zA-Z]+([0-9]+))&lt;/string&gt;\\W+&lt;key&gt;thumb&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;\\W+&lt;/dict&gt; 替换的正则表达式：1&lt;dict&gt;\\n&lt;key&gt;ColorFilter&lt;/key&gt;\\n&lt;integer&gt;58&lt;/integer&gt;\\n&lt;key&gt;ColorFilterConfigPath&lt;/key&gt;\\n&lt;string&gt;preFilters/\\5/filterConfig.plist&lt;/string&gt;\\n&lt;key&gt;Icon&lt;/key&gt;\\n&lt;string&gt;\\6&lt;/string&gt;\\n&lt;key&gt;MVID&lt;/key&gt;\\n&lt;string&gt;\\4&lt;/string&gt;\\n&lt;key&gt;Title&lt;/key&gt;\\n&lt;string&gt;\\1&lt;/string&gt;\\n&lt;key&gt;TitleTranslation&lt;/key&gt;\\n&lt;dict&gt;\\n&lt;key&gt;zh-Hant&lt;/key&gt;\\n&lt;string&gt;\\3&lt;/string&gt;\\n&lt;key&gt;en&lt;/key&gt;\\n&lt;string&gt;\\2&lt;/string&gt;\\n&lt;/dict&gt;\\n&lt;/dict&gt; ###歌词信息读取 歌词文件的样式（尖括号中为时间戳，后接一段歌词）： 1&lt;0,626&gt;killing &lt;627,626&gt;spring&lt;627,626&gt;kill ing&lt;627,626&gt;我是一段 歌词### &lt;627,626&gt;我是一句歌词~ ~~ 用于匹配的正则表达式： 1&lt;([0-9]+),([0-9]+)&gt;([\\w|\\W]+?)(?=&lt;|$) 可以将匹配到的子串转换为 JSON 格式： 1&#123;\\n&quot;stamp1&quot;: \\1,\\n&quot;stamp2&quot;: \\2,\\n&quot;content&quot;: \\3\\n&#125;,\\n","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://punmy.cn/tags/正则表达式/"},{"name":"技能","slug":"技能","permalink":"http://punmy.cn/tags/技能/"}]}]}