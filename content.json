{"meta":{"title":"Punmy","subtitle":"Codes, thoughts and stories","description":"潘名扬的博客","author":"Nico","url":"http://punmy.cn"},"pages":[{"title":"About","date":"2018-09-07T19:28:11.782Z","updated":"2018-04-07T17:08:15.000Z","comments":true,"path":"about/index.html","permalink":"http://punmy.cn/about/index.html","excerpt":"","text":"希望能在这个博客里记录下我平时的一些想法。"},{"title":"Categories","date":"2018-09-07T19:28:11.793Z","updated":"2017-07-31T15:43:13.000Z","comments":true,"path":"categories/index.html","permalink":"http://punmy.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-09-07T19:28:12.129Z","updated":"2017-07-31T15:43:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://punmy.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"代码比对神器 Kaleidoscope","slug":"效率神器 Kaleidoscope","date":"2019-02-28T15:31:03.000Z","updated":"2019-03-03T14:08:03.405Z","comments":true,"path":"2019/02/28/效率神器 Kaleidoscope.html","link":"","permalink":"http://punmy.cn/2019/02/28/效率神器 Kaleidoscope.html","excerpt":"简介Kaleidoscope 是一个非常强大的比对工具，可以十分方便地比对文本、图片、文件夹等内容。搭配上 SourceTree，能够大大提升 Git 的效率。","text":"简介Kaleidoscope 是一个非常强大的比对工具，可以十分方便地比对文本、图片、文件夹等内容。搭配上 SourceTree，能够大大提升 Git 的效率。 SourceTree 和 Kaleidoscope 配合起来可以使得 Code Review 和冲突解决变得十分高效。他们配合起来可以做到，在 SourceTree 中选择任意两个 Commit，按下快捷键就唤起 Kaleidoscope 进行比对。对于重视 Code Review 的团队来说，可以说是一个非常能够提升体验的效率工具。我想只有 Code Review 体验的提高，才能让团队里的成员更有 Code Review 的意愿，才能真正推动 Code Review 的进行。 下面我将在本文中分享一下 SourceTree + Kaleidoscope 的配置。 Kaleidoscope 可以用来： 比对任意文字、图片、文件夹 Code Review 利器，可以比对 Git 中不同 commit、不同分支上的代码 快速解决 Git 合并冲突 配置步骤1、安装好 SourceTree 和 Kaleidoscope 2、进入 Kaleidoscope 菜单 &gt; Intergration… 安装命令行工具 如下图所示，遵循指示，把Kaleidoscope和Git两个 Tab 中的命令行工具都安装好。安装完成后，左侧会出现✅标志。 3、打开 SourceTree &gt; Preference &gt; Diff 配置 External Diff / Merge 选项 Diff 和 Merge 的工具都选择 Custom，然后填入如下配置： Diff Command： /usr/local/bin/ksdiffArguments： --partial-changeset --relative-path &quot;$MERGED&quot; -- &quot;$LOCAL&quot; &quot;$REMOTE&quot; Merge Command： /usr/local/bin/ksdiffArguments： --merge --output &quot;$MERGED&quot; --base &quot;$BASE&quot; -- &quot;$LOCAL&quot; --snapshot &quot;$REMOTE&quot; --snapshot 使用 Custom 配置是因为 SourceTree 对 Kaleidoscope 的原生支持有 Bug 4、配置 Custom Actions 以便快速唤起对比工具 在 Custom Actions 中增加一个配置，配上你希望唤醒对比工具的快捷键，这里我使用 ⇧+⌘+D。然后在 Script 中填入：git，在 Parameters 中填入：difftool -y -t sourcetree $SHA。然后就配置完成了。 使用方法 比对任意两个 commit 之间的改动： 按住⌘，选择两个commit，点击刚刚配置的快捷键，即可唤起 Kaleidoscope 查看某个文件的改动：直接右键单击文件，选择 External Diff（也可以对照上面的方法加个快捷键） 解决冲突：右键单击冲突的文件，使用外部工具解决冲突(如下图)","categories":[{"name":"工具","slug":"工具","permalink":"http://punmy.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://punmy.cn/tags/工具/"}]},{"title":"iOS上的端序","slug":"Endianness In iOS","date":"2018-12-08T11:31:03.000Z","updated":"2018-12-08T11:53:00.790Z","comments":true,"path":"2018/12/08/Endianness In iOS.html","link":"","permalink":"http://punmy.cn/2018/12/08/Endianness In iOS.html","excerpt":"什么是端序端序，也叫字节序，是指计算机上多字节数据类型的存储规则。在日常的编码中可能不太需要关心端序，但当涉及到一些比较底层的任务，例如 socket 编程时，就绕不开它。","text":"什么是端序端序，也叫字节序，是指计算机上多字节数据类型的存储规则。在日常的编码中可能不太需要关心端序，但当涉及到一些比较底层的任务，例如 socket 编程时，就绕不开它。 端序（Endian）有两种规则，一种是大端序，一种是小端序。大端序是指将高位字节存放在低位地址，而小端序则是将低位字节存放在低位地址。以0x01234567为例。 大端序： 低地址 高地址 0x01 0x23 0x45 0x67 小端序： 低地址 高地址 0x67 0x45 0x23 0x01 iOS上的端序目前为止，iOS 上采用的端序是小端序。在 NSByteOrder.h 和 OSByteOrder.h 中有许多和端序相关的定义，其中当前系统的端序可以通过 NSHostByteOrder() 获取到： 123if (NSHostByteOrder() == NS_BigEndian) &#123; NSLog(@\"BigEndian\");&#125; 端序的转换不同的设备或协议可能采用不同的端序，例如，iPhone 和 x86 架构的 PC 都采用小端序，USB协议也采用小端序；而许多网络协议，如 TCP/IP 协议，以及部分 PC 则采用大端序。此外，ARM 等平台的端序则是可以配置的。因此，当涉及到 socket、信号处理等比较底层的操作时，我们需要注意不同场合下所需的端序，按需进行转换。 不同的语言中通常都有对应的 ntoh* 和 hton* 方法，来进行端序的转换。TCP/IP 协议中规定了数据采用大端序，因此大端序也常常被称作网络端序。相反地，小端则被称作主机端序。这也是我们常常见到的端序转换方法名 ntoh*（network-to-host）、hton*(host-to-network) 的由来。 12345// 转换端口号的端序struct sockaddr_in addr;addr.sin_port = htons(port);addr.sin_family = AF_INET;addr.sin_addr.s_addr = inet_addr(kLocalhost); 根据数据的字节数的不同，Darwin 为我们提供了一系列常用的宏来转换端序：ntohs(16bits)、ntohl(32bits)、ntohll(64bits)、htons(16bits)、htonl(32bits)、htonll(64bits).如果需要进行更长字节数的端序转换，则需要我们自己实现。 123456// Int16 的端序转换宏#define ntohs(x) __DARWIN_OSSwapInt16(x)// 判断是否常量，使用不同的转换方式#define __DARWIN_OSSwapInt16(x) \\ ((__uint16_t)(__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt16(x) : _OSSwapInt16(x))) 1234// 常量的端序转换方法，在预处理阶段完成（uint16）#define __DARWIN_OSSwapConstInt16(x) \\ ((__uint16_t)((((__uint16_t)(x) &amp; 0xff00) &gt;&gt; 8) | \\ (((__uint16_t)(x) &amp; 0x00ff) &lt;&lt; 8))) 123456789// 运行时的端序转换方法（uint16）__DARWIN_OS_INLINE__uint16_t_OSSwapInt16( __uint16_t _data)&#123; return ((__uint16_t)((_data &lt;&lt; 8) | (_data &gt;&gt; 8)));&#125; 查看这些宏的定义可以发现，Darwin 会先判断待转换的数据是否常量，如果是常量，则直接进行移位运算，在编译前的预处理阶段就完成转换；如果是变量，则替换为相应的内联方法，在运行时进行转换。","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"基础","slug":"基础","permalink":"http://punmy.cn/tags/基础/"}]},{"title":"巧妙利用KVO实现精准的VC耗时检测","slug":"15278496835424","date":"2018-06-18T08:50:03.000Z","updated":"2018-06-18T08:50:37.000Z","comments":true,"path":"2018/06/18/15278496835424.html","link":"","permalink":"http://punmy.cn/2018/06/18/15278496835424.html","excerpt":"本文主要想分享一下我在根据这篇博客 《一种基于KVO的页面加载，渲染耗时监控方法》 实现 VC 耗时检测的过程中，产生并解决的疑惑，以及在该博客中发现的问题。本文最终输出了一个用于检测 VC 加载耗时的小工具：VCProfiler。","text":"本文主要想分享一下我在根据这篇博客 《一种基于KVO的页面加载，渲染耗时监控方法》 实现 VC 耗时检测的过程中，产生并解决的疑惑，以及在该博客中发现的问题。本文最终输出了一个用于检测 VC 加载耗时的小工具：VCProfiler。 本文的实现基于 @盗版五子棋 的博客，并在其基础之上进行了一点改进。最终的源代码发布在 Github 上：VCProfiler。 背景View Controller 的加载耗时优化是 App 性能优化中的一个重要环节，也是用户对于 App 流畅度的一个直观感知。 公司内部的性能监测工具中，也一直有对 VC 的加载耗时进行检测，但是之前的方法是在 load 方法中，用 Method Swizzle 的方式替换 UIViewController 的 init、loadView、ViewDidLoad 等方法，并在其中记录对应的时间戳，以此来计算 VC 加载过程中各个阶段的耗时。 这样的检测方式不是很精准，因为我们 hook 的是 UIViewController 的方法，如果我们在自己的 VC 中重写了对应的方法，并执行了一些耗时的操作，那么这些操作的时间就没有被计算进去。因此我们需要改进现有的检测方式，以便更加精准地测量 VC 加载过程中的耗时。 发现新大陆在研究新方法的过程中，我发现了@盗版五子棋 写的一篇博客《一种基于KVO的页面加载，渲染耗时监控方法》，这篇博客中描述了一种很巧妙的检测 VC 耗时的思路。 这个思路利用了 KVO 在实现上的一些特性，简单来说，就是在 VC 创建的时候，故意触发 KVO，让 runtime 在我们自定义的 VC 对象上，再动态地包装一层 KVO 的子类，然后像之前一样 hook 这个子类 VC 的各个关键的方法，在其中进行时间的记录。这样一来，我们不再仅仅是检测父类的耗时，而是直接能够测量出我们自己 VC 本身的方法耗时。 我的疑惑具体的一些原理和实现方式 @盗版五子棋 的博客中已经写的非常详细，我在此就不再赘述。但在读那篇博客的过程中，我心里一直有个疑问： 既然 hook 了父类，也就是 UIViewController 的 init 方法，那为什么不直接在父类的 init 方法中，获取子类 VC 的类型，然后替换子类 VC 的各个关键方法？ 底下的评论中也有类似的疑问，但当时没有看到作者的明确回复，因此我就分别按照两种方法实现了一下 VC 的耗时检测，在实现的过程中，突然意识到了使用 KVO 的优势。 为何选择 KVO直接 hook 各个 VC 类的方法，在一般的情况下也是能实现相应的耗时检测的，但是在各个 VC 之间存在继承关系的时候，会导致子类和父类重复 hook，甚至一不小心就会在 Method Swizzle 的时候把 IMP 换错掉。 假设我们有两个 VC，一个是 A，一个是 B，B 继承于 A。如果直接 hook 各个 VC 的方法，那么 A 和 B 都会被 hook 一次，当我们在加载 B 的时候，A、B 两个类的耗时检测都会被触发。而对于 KVO 的方法而言，由于每次 hook 的都是系统动态生成的 KVO 类，完全不会影响到原有的 A 和 B，所以 B 继承下来的 A 依然是纯净的 A，不会受到干扰。 这是我觉得 KVO 的方法带来的最大的好处。 发现的问题问题1、不需要 hook init 方法原文在提到 hook UIViewController 的 init 方法的时候，同时 hook 了三个 init 方法： init initWithCoder: initWithNibName:bundle: 但其实 -init 方法是没有必要 hook 的，因为 UIViewController 的 -init 方法最终也是调用 initWithNibName:bundle: 来进行初始化。如果同时 hook 了 -init 方法，会导致一次多余的操作。 因此，我们只需要 hook 两个初始化方法就够了： initWithCoder: initWithNibName:bundle: 问题2、KVORemover 对 VC 的引用要用 unsafe_unretained另一个问题是，原文中提到，使用一个 KVO remover 在 dealloc 的时候移除 VC 的 KVO： 然后我们构建一个移除器，这个移除器弱引用保存了vc的实例和对应的keypath…………而在对应的移除器的dealloc方法里，我们把kvo监听给移除就可以了。 123456789- (void)dealloc&#123;#ifdef DEBUG NSLog(@\"WZQKVORemover called\");#endif if (_obj) &#123; [_obj removeObserver:[WZQKVOObserverStub stub] forKeyPath:_keyPath]; &#125;&#125; 实际实现中，使用 associate object 来移除 KVO 的正确性确实是有保障的，但是，如果 remover 保存的 VC 实例，也就是obj属性，使用了 weak 来修饰，那么在 remover 进入 -dealloc 方法的时候，上述代码中的 if (_obj) 判断将永远为 false。因为在 dealloc 的时候，weak 修饰的属性已经被置为 nil（但是在此处断点的话，Xcode 中仍然看得到 obj 原先的值），也就无法正常移除 KVO。 因此 remover 中引用的 VC 实例需要使用 unsafe_unretained 来修饰。 总结利用 KVO 动态创建子类的方式来 hook VC，并计算耗时，这确实是一个很有意思的想法，同时也非常的简单有效。此外，由于所有的工作都可以在 UIViewController 的 Category 中实现，也使得这种方式基本没有侵入性。鉴于 @盗版五子棋 文章中的 Github 链接是无效的，我已经将实现好的代码发布在了 Github 上，有需要的同学可以自取：VCProfiler。","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"工具","slug":"工具","permalink":"http://punmy.cn/tags/工具/"}]},{"title":"iOS 最全面的功耗分析之——Power Log","slug":"iOS 最全面的功耗分析之——Power Log","date":"2018-06-12T04:31:03.000Z","updated":"2019-03-03T14:07:48.420Z","comments":true,"path":"2018/06/12/iOS 最全面的功耗分析之——Power Log.html","link":"","permalink":"http://punmy.cn/2018/06/12/iOS 最全面的功耗分析之——Power Log.html","excerpt":"前言功耗分析是移动应用开发中一个非常重要的课题，也是衡量应用性能表现的一个重要指标。但是在 iOS 设备上，由于苹果严格的限制，我们一直较难开展功耗分析的工作。","text":"前言功耗分析是移动应用开发中一个非常重要的课题，也是衡量应用性能表现的一个重要指标。但是在 iOS 设备上，由于苹果严格的限制，我们一直较难开展功耗分析的工作。 在 iOS 10 以前，我们还可以通过 IOKit 中的 IOPMPowerSource 私有接口，获取较为详细的电量信息，如电量、电压、电池温度等一系列的信息，腾讯的 GT 就是通过该接口获取电池的信息。然而，在 iOS 10 以及更高的系统中，该接口也被封印了，现在读取该接口，只能获取到很鸡肋的信息，如下图所示。 因此，iOS 平台上急切地需要一个功耗分析的工具。 Power Log（Sysdiagnose）我们都知道，iOS 系统本身是有对电量的使用情况进行记录和分析的，所以我们才能在系统设置里看到过去一段时间里，各个 App 的前台工作时间和耗电情况。在进行了一整天的调研后，我震惊地发现，iOS 的耗电记录是可以导出的，并且它记录的详细程度简直令人发指！简单地说，它包括了过去几天里，系统整体的详细功耗情况、各个 App 在各个硬件上的耗电情况（包括第三方 App），等等一系列详细的数据。 有的同学可能遇到过，在向苹果反馈 Bug 时，有时苹果的工程师会要求你附上设备的诊断日志，其中，在遇到电池续航相关的问题时，苹果的工程师会让你提供一下电池的诊断日志。在电池的诊断日志中，就包含了电池电量的使用记录。 这些诊断工具在之前被苹果称为 Sysdiagnose，现在，它们被苹果统一归类到 Bug Reporting 的主题中，电池续航相关的诊断日志被称为“Power Log”。 我在苹果的 Bug Reporting 中发现了一份电池诊断日志的导出指南，其中仅仅简短地介绍了导出日志的几个步骤。我按照其中的步骤成功导出了电池续航日志，发现该日志其实是一个数据库，其中储存了几十张表。至于这几十张表中存储的内容是什么，各个字段的含义是什么，以及如何分析其中的数据，苹果的指南中则只字未提。好在经过一番查找后，我发现了腾讯的一篇博客 中有提到其中几张表的内容，有了这个开头后，我便顺腾摸瓜，大致了解了其中的结构。 下面，我简单地介绍一下，如何通过这个方法获取最全面的功耗信息，以及如何分析其中的数据。 获取数据苹果在电池诊断日志的导出指南中详细说明了导出日志的步骤。我这里简要说明一下大概的步骤。 首先在你的测试机上，安装电量分析的 profile，安装完成后，iOS 才会记录最详细的功耗数据，并开放读取；（推荐下载后用 Airdrop 发送到手机上安装） 第二步，连接上 iTunes 并同步，这时 iTunes 就会自动把手机上的功耗的历史记录拷贝到电脑上； 第三步，断开设备，运行你的 App，这时设备已经在记录功耗信息，记得留意你运行 App 时的时间，因为稍后要和数据库中的时间戳进行匹配； 第四部，再次连接上 iTunes 并同步，这时 iTunes 就会自动把手机上的详细功耗记录拷贝到电脑上； 诊断日志的目录到 iTunes 的同步文件夹（~/Library/Logs/CrashReporter/MobileDevice/你的手机名/）下，找到以Powerlog_开头，后缀是.PLSQL或者.PLSQL.gz的几个文件，这些就是记录了所有功耗信息的数据库文件了，可以使用简单的数据库查看工具打开看看。 分析数据打开数据库后，我们可以看到里面有数百张表。苹果没有解释这些表的具体作用，只介绍了如何导出，因为苹果实际上只打算用这份记录来诊断问题，目前并没有直接向开发者开放。但我们可以通过各个表中的字段名，来了解各个表的大概用途。此外，腾讯的文档中介绍了其中比较重要的七张表，这节省了我们不少时间。下面列举一下关键的几张表的作用。 表名 内容 PLBatteryAgent_EventBackward_Battery 整机的电量信息，包含电流、电压、温度等信息。（每20秒记录一条数据） PLBatteryAgent_EventBackward_Battery_UI 剩余电量百分比。（每20秒记录一条数据） PLIOReportAgent_EventBackward_EnergyModel 整机不同硬件上的详细功耗数据。分别记录了 CPU、GPU、DRAM 等硬件的耗电量。 PLAccountingOperator_Aggregate_RootNodeEnergy 各个 App 的详细耗电数据。记录各个 App 在各个硬件上的耗电量。（每小时更新一次数据） PLAccountingOperator_EventNone_Nodes 各个硬件对应的 Node ID，以及各个 App 的对应的 Node ID。 PLAccountingOperator_EventNone_AllApps 手机中安装的所有 App 的信息 PLApplicationAgent_EventForward_Application App 运行状态记录。记录各个 App 在某个时间段以什么状态运行。 PLAppTimeService_Aggregate_AppRunTime App 的运行时长统计。（每小时更新一次数据。 PLBatteryAgent_EventForward_LightningConnectorStatus Lighting 接口连接状态 PLBatteryAgent_EventNone_BatteryConfig 电池的配置信息。包括电池容量、循环计数、电池寿命、电池温度等信息。 PLBatteryAgent_EventNone_BatteryShutdown 电池导致的意外关机记录。 PLButtonAgent_EventPoint_Button 疑似物理按键的点击记录。 PLCameraAgent_EventForward_Camera 相机使用记录。记录了相机类型和使用相机的 App PLConfigAgent_EventNone_Config 本机的一些配置信息和一些系统设置。 PLDisplayAgent_Aggregate_UserTouch 屏幕点击计数。每 15 分钟记录一条数据。 PLDisplayAgent_EventForward_Display 屏幕亮度信息。包括流明、尼特、亮度滑竿值等信息。 PLProcessNetworkAgent_EventPoint_Connection 网络连接记录。记录了发起网络连接的 App、地址、端口等信息。 PLXPCAgent_EventPoint_CacheDelete 清除缓存的记录。包括申请的空间大小、清除缓存的耗时、清除的缓存大小、服务名称、紧急程度等信息。 我们结合几张表就可以简单地分析出一些衡量耗电量的维度，例如： 1、绘制电量百分比变化曲线直接读取 PLBatteryAgent_EventBackward_Battery_UI 表中的数据即可。 2、iPhone 整体耗电量和温度变化直接读取 PLBatteryAgent_EventBackward_Battery 表中的电量、温度数据，数据的记录间隔是 20 秒，基本上满足了各种各样的需求。 3、分析特定 App 的详细功耗数据结合 PLAccountingOperator_Aggregate_RootNodeEnergy 和 PLAccountingOperator_EventNone_Nodes 两张表，可以得到某个 Bundle ID 对应的 App 在各个硬件上的耗电情况。 由于 PLAccountingOperator_Aggregate_RootNodeEnergy 中的每条数据，是记录该时间点之前一个小时内的耗电情况，所以我们可以知道在每个小时内，这个 App 在各个硬件上的耗电情况。例如，我们可以查到美拍在过去一个小时内的耗电情况，如下图所示，从中我们可以找出耗电较多的硬件，其中，耗电最多的是 RootNodeID 为 10 的硬件，也就是屏幕。 总结Power Log 能够为我们提供十分详细和准确的功耗数据，从细节到整体都能够兼顾到。并且根据苹果官方的说法，记录详细的功耗数据并不会导致 iPhone 性能的下降，只是会占据一定的磁盘空间。不过，也因为它的数据量太大，导致它对我们不太友好。我们需要用 SQL 去读取、处理庞杂的原始数据，才能得到理想的信息。最好的方案是为此开发一个读取和分析的前端，这样才能够提高效率。此外，由于它的数据是离线获取的，这在某些情况下可能不是很方便。 但总的来说，Power Log 是十分强大的，它记录的信息之丰富让人印象深刻，也为我们的功耗分析提供了更好更强大的手段。","categories":[{"name":"工具","slug":"工具","permalink":"http://punmy.cn/categories/工具/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"工具","slug":"工具","permalink":"http://punmy.cn/tags/工具/"}]},{"title":"条件变量（Condition Variables）","slug":"条件变量（Condition Variables）","date":"2018-06-06T17:31:03.000Z","updated":"2018-06-06T17:33:17.000Z","comments":true,"path":"2018/06/07/条件变量（Condition Variables）.html","link":"","permalink":"http://punmy.cn/2018/06/07/条件变量（Condition Variables）.html","excerpt":"1、是什么条件变量是并发编程中的一种同步机制。条件变量使得线程能够阻塞到等待某个条件发生后，再继续执行。条件变量能够实现强大并且高效的同步机制，但是要用好条件变量，也需要我们做出不少努力。","text":"1、是什么条件变量是并发编程中的一种同步机制。条件变量使得线程能够阻塞到等待某个条件发生后，再继续执行。条件变量能够实现强大并且高效的同步机制，但是要用好条件变量，也需要我们做出不少努力。 2、为什么需要条件变量设想一下这样子的场景：在生产者消费者模型中，我们希望在生产者制造出 100 个产品后，庆祝一下。如果我们直接用 mutex 互斥锁来实现的话，那么我们需要在某个线程上不断地轮询：现在是不是做出 100 个产品了？伪代码如下： 1234567891011121314151617181920// Thread Producerproduce () &#123; mutex_lock() count++ mutex_unlock() &#125;// Thread AcelebrateAfter100 () &#123; while (1) &#123; mutex_lock() if (count &gt;= 100) &#123; mutex_unlock() break &#125; mutex_unlock() sleep(100) &#125; // Celebrate!&#125; 相当于我们要进行大量无效的询问，才能知道条件已经满足，并且每次询问都是需要加锁的，这无疑是一种资源的浪费。 而条件变量则高效地解决了这个问题。使用条件变量的情况下，我们可以直接等待某个条件的发生，而不需要主动轮询。有了条件变量，上述伪代码就可以很方便地改写成： 12345678910111213141516171819// Thread Producerproduce () &#123; mutex_lock() count++ mutex_unlock() if (count &gt;= 100) cond_signal(condition) // 条件满足啦，通知一个等待的线程&#125;// Thread AcelebrateAfter100 () &#123; mutex_lock() while(count &lt; 100) cond_wait(condition) // 等到条件满足再继续执行 mutex_unlock() // Celebrate!&#125; 现在相当于是在条件满足的时候，由生产者通知 Thread A，而不是让 Thread A 傻傻地去不断轮询，变得高效了很多。 3、如何正确使用条件变量来看一个简单的栗子： 123456789101112131415161718192021222324252627282930313233343536#include &lt;pthread.h&gt;static int value = 0;static pthread_mutex_t mutex;static pthread_cond_t condition;void setup()&#123; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;condition, NULL);&#125;void destroy()&#123; pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;condition);&#125;void waitCondition()&#123; pthread_mutex_lock(&amp;mutex); while (value == 0) &#123; pthread_cond_wait(&amp;condition, &amp;mutex); // 开始等待，并立即解锁 mutex &#125; pthread_mutex_unlock(&amp;mutex);&#125;void triggerCondition()&#123; pthread_mutex_lock(&amp;mutex); value = 1; pthread_mutex_unlock(&amp;mutex); pthread_cond_broadcast(&amp;condition); // 广播&#125; 3.1、创建和销毁条件变量首先，条件变量在使用前必须初始化，pthread_cond_init 和 pthread_cond_destroy 方法可以用来动态创建和销毁条件变量。 同时，条件变量和互斥锁一样，也有静态创建方式，静态方式使用 PTHREAD_COND_INITIALIZER 常量，如下： 1pthread_cond_t condition = PTHREAD_COND_INITIALIZER; 此外，因为条件变量必须配合互斥锁使用，所以也要创建一个互斥锁。 3.2、与互斥锁配合使用为了防止发生竞争条件，条件变量必须与互斥锁搭配使用。pthread_cond_wait 函数的调用 和 临界区 都需要受到互斥锁的保护。 3.3、等待条件的发生当条件不满足时，使用 pthread_cond_wait 或者 pthread_cond_timedwait 函数，来让线程进入休眠。当函数正常返回时，返回值为 0。 这两个函数的区别在于，pthread_cond_timedwait 函数提供了超时返回的能力，我们可以设定一个超时时间，来避免永久的等待。当到达超时时间后，条件变量仍未满足的话，函数会返回 ETIMEOUT。其中 abstime 以绝对时间的形式出现，0 表示格林尼治时间1970年1月1日0时0分0秒，这里常常有人误解为相对时间。 这两个 wait 函数的调用，都要在获取 mutex 锁后进行。 看到这里可能有的人会觉得疑惑：如果在 wait 之前锁住了 mutex，那其他线程在试图进入临界区时（上文 value = 1 的那行代码），不就永远获取不到 mutex 了吗？ 这确实是让许多初学者觉得困惑的地方。其实函数 pthread_cond_wait 会在线程即将休眠之前，释放 mutex。因此，在线程休眠之后，其他线程就能正常锁住 mutex 了。 而后，等到其他线程触发了条件，并且 unlock 了 mutex 之后，休眠的线程在 wait 函数中会再次锁住 mutex，然后继续执行代码。 12345678pthread_mutex_lock(&amp;mutex);while (value == 0) &#123; /* 解锁 mutex，线程开始休眠，等待条件变量触发... * 等到条件变量被触发，线程被唤醒， * 在 pthread_cond_wait 返回之前，会再次锁住 mutex */ pthread_cond_wait(&amp;condition, &amp;mutex); &#125;pthread_mutex_unlock(&amp;mutex); 3.4、条件触发其他线程可以在条件满足后，通过调用 pthread_cond_signal 或者 pthread_cond_broadcast 来触发条件变量。 123456789void triggerCondition()&#123; pthread_mutex_lock(&amp;mutex); value = 1; pthread_mutex_unlock(&amp;mutex); pthread_cond_broadcast(&amp;condition); // 唤醒所有等待中的线程，不需要加锁&#125; pthread_cond_signal 函数可以唤醒一个处于等待中的线程，当有多个线程等待时，它会自动根据线程的优先级选择一个线程唤醒。但是某些特殊情况下，该函数可能会唤醒不止一个线程。 pthread_cond_broadcast 函数则是用“广播”的方式唤醒所有等待中的线程。例如读写锁的实现中，在写入完毕后，可以用它来唤醒所有等待中的读取操作。 值得注意的是，无论是 pthread_cond_signal 还是 pthread_cond_broadcast 都不保证唤醒的正确性。也就是说，休眠中的线程有可能在被唤醒后，发现条件依旧不满足。这是由于在函数的实现中，为了追求高性能，而放弃了一定的准确性。这通常被称为“虚假唤醒”。 此外，pthread_cond_signal 和 pthread_cond_broadcast 函数都不需要在 mutex 锁中调用。 4、注意尽管条件变量的使用是较为简单的，但是其中也有不少的“坑”需要大家注意。下面介绍几个比较值得注意的问题。 4.1、要考虑解锁和唤醒的顺序由于 pthread_cond_signal 和 pthread_cond_broadcast 函数的调用都不需要加锁，所以它们放到 pthread_mutex_unlock 之前或者之后执行都是可以的。但在实际使用中，需要根据具体情况考虑它们的顺序，来使得程序高效运行。 当 signal 操作发生在 unlock 之前时，其他等待的线程被唤醒，但 mutex 锁可能仍然被 signal 的线程持有着，导致被唤醒的线程无法获取到 mutex 锁，从而再次进入休眠。通常情况下，这种调用顺序就会对代码的执行效率产生不良的影响。但是在 Java 下，必须采用这种顺序进行调用，否则会发生异常。 4.2、要使用 while 而不是 if，避免虚假唤醒细心观察可以发现，我们在等待的线程中，使用的是 while (条件不成立) 的方式来调用 wait 函数，而不是使用 if 语句。 这是由于 wait 函数被唤醒时，存在虚假唤醒等情况，导致唤醒后发现，条件依旧不成立。因此需要使用 while 语句来循环地进行等待，直到条件成立为止。 4.3、timewait 是 absolute timepthread_cond_timedwait 函数的 abstime 指的是超时的绝对时间，而不是相对现在的时间间隔。这点经常会有人误会。 4.4、pthread_cond_timedwait 不一定会准时返回如果 pthread_cond_timedwait 超时到了，但是这个时候 mutex 锁被其他线程持有，导致本线程不能锁定 mutex，无法进入临界区，那么 pthread_cond_timedwait 就无法立即返回。 5、NSConditionNSCondition 是 Objective-C 中对条件变量的封装，它的底层也是基于上文所述的 POSIX 的条件变量。用法也和上文的结构相似。它的独特之处在于，它同时封装了一个互斥锁和一个条件变量，所有的加锁和条件的操作都可以直接通过 NSCondition 对象完成。官方示例如下： 等待条件： 123456789[cocoaCondition lock];while (timeToDoWork &lt;= 0) [cocoaCondition wait];timeToDoWork--;// Do real work here.[cocoaCondition unlock]; 发送信号： 1234[cocoaCondition lock];timeToDoWork++;[cocoaCondition signal];[cocoaCondition unlock]; 6、参考文献 https://linux.die.net/man/3/pthread_cond_wait https://linux.die.net/man/3/pthread_cond_signal https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/com.ibm.aix.genprogc/condition_variables.htm https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html https://bestswifter.com/ios-lock/ https://blog.zorro.im/posts/ios-muti-threading-synchronization.html https://stackoverflow.com/questions/16522858/understanding-of-pthread-cond-wait-and-pthread-cond-signal https://blog.csdn.net/gettogetto/article/details/53872929","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"基础","slug":"基础","permalink":"http://punmy.cn/tags/基础/"},{"name":"并发编程","slug":"并发编程","permalink":"http://punmy.cn/tags/并发编程/"}]},{"title":"HTTP/2 初探","slug":"15041894895980","date":"2017-08-31T14:24:00.000Z","updated":"2017-10-25T16:31:01.000Z","comments":true,"path":"2017/08/31/15041894895980.html","link":"","permalink":"http://punmy.cn/2017/08/31/15041894895980.html","excerpt":"HTTP/2 是一个比它的几个前任更快、更简单、更稳定的 HTTP 协议。在 HTTP/2 中，我们可以摒弃掉很多以往针对 HTTP/1.1 想出来的“歪招儿”，因为它们的解决方案都内置在了传输层中。不仅如此，它还为我们进一步优化应用和提升性能提供全新的机会！","text":"HTTP/2 是一个比它的几个前任更快、更简单、更稳定的 HTTP 协议。在 HTTP/2 中，我们可以摒弃掉很多以往针对 HTTP/1.1 想出来的“歪招儿”，因为它们的解决方案都内置在了传输层中。不仅如此，它还为我们进一步优化应用和提升性能提供全新的机会！ 从 SPDY 到 HTTP/2SPDY 是 Google 在 2009 年发布的一个实验性协议，它是一个应用层的网络传输协议，也是 HTTP/2 的前身。SPDY 并不是为替代 HTTP 而生，它的目的是通过多路复用、请求优化和 HTTP 头部压缩等功能，来最小化 HTTP/1.1 的各种性能限制所导致的延迟。具体来说，这个项目设定的目标如下： 页面加载时间 (PLT) 减少 50%。 无需网站作者修改任何内容。 将部署复杂性降至最低，无需变更网络基础设施。 与开源社区合作开发这个新协议。 收集真实性能数据，验证这个实验性协议是否有效。 首次发布后不久，Google 分享了 SPDY 协议的实现结果、文档和源代码，宣布在实验室条件下取得了 55% 的速度提升。 几年后的 2012 年，这个新的实验性协议得到了 Chrome、Firefox 和 Opera 的支持，越来越多的网站开始在部署 SPDY。事实上，在行业中被越来越多地采用之后，SPDY 已经具备了成为一个标准的条件。 观察到这一趋势后，HTTP 工作组将这一工作提上议事日程，吸取 SPDY 的经验教训，并在此基础上制定了官方“HTTP/2”标准。在拟定草案、向社会征集 HTTP/2 建议并经过内部讨论之后，HTTP 工作组决定将 SPDY 规范作为新 HTTP/2 协议的基础。 在接下来几年中，SPDY 和 HTTP/2 继续共同演化，SPDY 作为实验性分支，为 HTTP/2 标准测试新功能和建议，对要包含到 HTTP/2 标准中的每条建议进行测试和评估。最终，这个过程持续了三年，期间产生了十余个中间草案。 最终，在2015 年初，IETF 审阅了新的 HTTP/2 标准并批准发布。SPDY 与 HTTP/2 的共同演化使得它在诞生之日就已经是一个经过大量实践的标准，发布后不久，就得到了广泛应用。 为何选择 HTTP/2HTTP/1.x 的问题想了解 HTTP/2 的优势，就得从 HTTP/1.x 存在的问题说起。 HTTP/1.x 中存在许多问题使得它越来越难以满足快速发展的互联网。 其中，HTTP/1.x 最大的问题就是一个连接同时只能处理一个请求。这意味着同一个连接下发起的多个请求只能逐个请求和接收。同时，由于没有优先级管理，HTTP/1.x 同一个连接中的多个请求只能采取 FIFO 的方式，依次完成。如果连接被某个耗时长的请求占用，那么其它所有请求就只能排队等候，直到收到回复或者超时。这就是所谓的队头阻塞（Head-of-Line Blocking，HOLB）。 这个问题的一个解决方案就是 HTTP pipelining。通过 HTTP pipelining，在同一个连接上，可以不等队伍前方的请求收到响应，就先行发送后续的请求。这样一来请求就不会有延迟，使得服务器可以提早开始处理请求，一些耗时长的，如涉及数据库查询的请求，就可以提早进行，理论上可以提高 HTTP 的效率。 然而，响应还是需要逐个排队接收，所以它并不是真正的多路复用，但至少是个不错的提升了（如果它按照理论运行的话）。在 pipelining 开启后，HOLB 依旧存在，因为 response 仍然是逐个接收的。甚至和之前比起来，使用 pipelining 后，HOLB 更明显了。此外，由于 pipelining 实现起来复杂度比较高，在实践中还常常出现各种错误，所以它并没有被广泛推广。事实上，大多数主流的浏览器都禁用了 pipelining。 另一个解决方案就是对同一个 host 同时开启多个 HTTP 连接，这样就可以并行请求和接收，能够更快地获取到多个资源。但这仍然存在一些问题，例如建立连接产生的资源损耗等。并且同个域名存在最大连接数，所以为了提高连接数，一些网站只好将网页上的资源部署到不同的域名下。除此之外，由于 TCP 的拥塞控制使得 TCP 连接在建立后有一个缓启动的过程，所以多连接的方案实际上贡献的性能提升并没有想象中那么多。 此外，HTTP/1.x 还存在文本协议开销大、缺乏首部压缩等问题。综合这些来看，HTTP/1.x 只意味着更高的系统需求，和更低的性能表现。 HTTP/2 的改进二进制分帧层HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。二进制分帧层指的是位于传输层与应用层的高级 HTTP API 之间一个新编码机制。HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。 简言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。这是 HTTP/2 协议所有其他功能和性能优化的基础。 由于编码方式的不同，HTTP/2 无法向下兼容，这也是 HTTP/2 的版本号是 2 而不是 1.2 的主要原因。 连接复用在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接。但 HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。这是 HTTP 2 最重要的一项增强。 HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。最终使得应用速度更快、开发更简单、部署成本更低。 值得注意的是，HTTP/2 解决了 HTTP 的 HOL 阻塞，但并没有解决 TCP 上的 HOL 阻塞。 数据流优先级将 HTTP 消息分解为很多独立的帧之后，客户端和服务器交错传输这些帧的顺序，就成为关键的性能决定因素。为了做到这一点，HTTP/2 允许每个数据流都有一个优先级和依赖关系。数据流依赖关系和权重的组合使得服务器可以使用此信息控制 CPU、内存和其他资源的分配，确保将高优先级响应以最优方式传输至客户端。 数据流依赖关系和权重表示传输优先级，而不是要求，因此不能保证特定的处理或传输顺序。即，客户端无法强制服务器通过数据流优先级以特定顺序处理数据流。 单一连接有了新的分帧机制后，HTTP/2 不再依赖多个 TCP 连接去并行复用数据流；每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。因此，所有 HTTP/2 连接都是持久的，而且每个来源仅需要一个连接，随之带来诸多性能优势。 大多数 HTTP 传输都是短暂且急促的，而 TCP 则针对长时间的批量数据传输进行了优化。 通过重用相同的连接，HTTP/2 既可以更有效地利用每个 TCP 连接，也可以显著降低整体协议开销。不仅如此，使用更少的连接还可以减少占用的内存和处理空间。这降低了整体运行成本并提高了网络利用率和容量。 标头压缩每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，标头中的数据始终以纯文本形式发送，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应中的标头数据，这种格式采用两种简单但是强大的技术： 这种格式支持通过静态 Huffman 编码对传输的标头字段进行编码，从而减小了各个传输的大小。 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表，此列表随后会用作参考，对之前传输的值进行有效编码。 作为一种进一步优化方式，HPACK 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段的列表；动态表最初为空，将根据在特定连接内改变的值进行更新。 流控制流控制是一种阻止发送方向接收方发送大量数据的机制。这很容易让人联想到 TCP 流控制，它们所要解决的问题很相似。不过，由于 HTTP/2 数据流在一个 TCP 连接内复用，TCP 流控制既不够精细，也无法提供必要的应用级 API 来调节各个数据流的传输。为了解决这一问题，HTTP/2 提供了一组简单的构建块，允许客户端和服务器实现其自己的流控制。 例如，HTTP2 的流控制允许浏览器仅提取一部分特定资源，通过将流控制窗口减小为零来暂停提取，稍后再行恢复。换句话说，它允许浏览器提取图像预览，进行显示并允许其他高优先级数据流继续传输，然后在更关键的资源完成加载后恢复提取。 服务端推送HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。之所以要提供这个服务，是因为一个文档被请求回来时，往往还需要再次请求很多文档内的其他资源，如果这些资源的请求不用客户端发起，而是服务端提前预判发给客户端，那么就会减少大量时延。 HTTP2 协议也没有规定服务器端到底该怎样推送这个资源。服务端可以自己制定不同的策略，可以是根据客户端明确写出的推送请求；或者是服务端通过学习得来；再或者是通过额外的HTTP首部想服务端表明意向。 这个服务的特点是： 只有建立连接后，服务器才可以推送资源(发送 PUSH_PROMISE 帧)，也就是说服务器不能无缘无故的主动向客户端推送资源。 客户端可以发送 RST_STREAM 拒绝服务器推送来的资源。 推送的资源可以由不同页面共享 服务器可以按照优先级来推送资源 iOS 对 HTTP/2 的支持在 iOS 上，NSURLSession 提供了对 HTTP/2 的支持。只要服务器支持 HTTP/2，系统就会自动使用它，否则将自动选择 HTTP/1.1 或其它可用协议。 需要注意的是，iOS 只支持加密连接的 HTTP/2 协议，HTTP/2 服务器需要支持 ALPN 或者 NPN 加密连接。 移动客户端网络部分的不少初步优化还比较依赖于 HTTP/2 的推进。MTHawkeye 中已经加入了对 HTTP/2 的检测，大家平时在开发的过程中，可以关注下，是否有可能将现存的 HTTP/1.x 升级到 HTTP/2。 延伸阅读 HTTP/2 简介 Brief History of HTTP Google 公布 HTTP/2 的博客 WWDC 711 HTTP pipelining ALPN 和 NPN 简介 QUIC 文档","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://punmy.cn/tags/网络/"},{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"基础","slug":"基础","permalink":"http://punmy.cn/tags/基础/"},{"name":"HTTP2","slug":"HTTP2","permalink":"http://punmy.cn/tags/HTTP2/"}]},{"title":"五分钟重拾正则表达式","slug":"15018607710939","date":"2017-08-04T15:01:00.000Z","updated":"2017-10-25T16:11:37.000Z","comments":true,"path":"2017/08/04/15018607710939.html","link":"","permalink":"http://punmy.cn/2017/08/04/15018607710939.html","excerpt":"什么是正则表达式正则表达式（Regular Expression，常简写为Regex）是一种表示文本规则的代码。在编写处理字符串的程序时，经常会有查找、替换符合某些规则的字符串的需要，正则表达式就是用于描述这些规则的工具。","text":"什么是正则表达式正则表达式（Regular Expression，常简写为Regex）是一种表示文本规则的代码。在编写处理字符串的程序时，经常会有查找、替换符合某些规则的字符串的需要，正则表达式就是用于描述这些规则的工具。 大多数人都在电脑上使用过用于文件查找的通配符，例如用“*.png”来查找所有的PNG格式的文件。正则表达式和通配符类似，也是用来进行文本匹配的工具。只是比起通配符，它能进行更精确的匹配，同时，也更为复杂。 正则表达式事实上是一种轻量级、简洁的编程语言，几乎所有的高级编程语言都支持正则表达式（语法不一定完全相同）。此外，大部分的代码编辑器，如 Sublime、VS Code 也都支持正则表达式的查找替换。因此，在学习正则表达式的时候，可以在 Sublime 之类的编辑器中进行尝试。 注：文件通配符与正则表达式无关。 基础语法字符正则表达式的语法中有普通字符和一些被称为“元字符”的特殊字符。 包括所有字母和数字字符在内的大部分字符，都是普通字符。普通字符只能匹配它们本身，如正则表达式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859只能匹配 ios 这个字符串（区分大小写）。下表是元字符及其行为的一个完整列表（转自维基百科。不是唯一的，不同的解析引擎可能略有不同）。| 字符 | 描述 || --- | --- || \\ | 将下一个字符标记为一个特殊字符（File Format Escape）、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\\\”匹配“\\”而“\\(”则匹配“(”。 || \\^ | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，\\^也匹配“\\n”或“\\r”之后的位置。 || $ | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 || * | 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于&#123;0,&#125;。 || + | 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于&#123;1,&#125;。 || ? | 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于&#123;0,1&#125;。 || &#123;n&#125; | n是一个非负整数。匹配确定的n次。例如，“o&#123;2&#125;”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 || &#123;n,&#125; | n是一个非负整数。至少匹配n次。例如，“o&#123;2,&#125;”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o&#123;1,&#125;”等价于“o+”。“o&#123;0,&#125;”则等价于“o*”。 || &#123;n,m&#125; | m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o&#123;1,3&#125;”将匹配“fooooood”中的前三个o。“o&#123;0,1&#125;”等价于“o?”。请注意在逗号和两个数之间不能有空格。 || ? | 非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，&#123;n&#125;，&#123;n,&#125;，&#123;n,m&#125;）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 || . | 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.|\\n)”的模式。 || (pattern) | 匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 || (?:pattern) | 匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 || (?=pattern) | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 || (?!pattern) | 正向否定预查（negative assert），在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 || (?&lt;=pattern) | 反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 || (?&lt;!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 || x|y | 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(?:z|f)ood”则匹配“zood”或“food”。 || [xyz] | 字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。特殊字符仅有反斜线\\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符\\^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。 || [\\^xyz] | 排除型字符集合（negated character classes）。匹配未列出的任意字符。例如，“[\\^abc]”可以匹配“plain”中的“plin”。 || [a-z] | 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 || [\\^a-z] | 排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[\\^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 || [:name:] | 增加命名字符类（named character class）[注 1]中的字符到表达式。只能用于方括号表达式。 || [=elt=] | 增加当前locale下排序（collate）等价于字符“elt”的元素。例如，[=a=]可能会增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ。只能用于方括号表达式。 || [.elt.] | 增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成。例如，29个字母表的西班牙语，&quot;CH&quot;作为单个字母排在字母C之后，因此会产生如此排序“cinco, credo, chispa”。只能用于方括号表达式。 || \\b | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 || \\B | 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 || \\cx | 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 || \\d | 匹配一个数字字符。等价于[0-9]。 || \\D | 匹配一个非数字字符。等价于[\\^0-9]。 || \\f | 匹配一个换页符。等价于\\x0c和\\cL。 || \\n | 匹配一个换行符。等价于\\x0a和\\cJ。 || \\r | 匹配一个回车符。等价于\\x0d和\\cM。 || \\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 || \\S | 匹配任何非空白字符。等价于[\\^ \\f\\n\\r\\t\\v]。 || \\t | 匹配一个制表符。等价于\\x09和\\cI。 || \\v | 匹配一个垂直制表符。等价于\\x0b和\\cK。 || \\w | 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 || \\W | 匹配任何非单词字符。等价于“[\\^A-Za-z0-9_]”。 || \\ck | 匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法。 || \\xnn | 十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。. || \\num | 向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\\1”匹配两个连续的相同字符。 || \\n | 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 || \\nm | 3位八进制数字，标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 || \\nml | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 || \\un | Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 |### 转义当需要匹配元字符本身的时候，为元字符加上“ \\ ”转义即可。### 匹配字符集合方括号“ [ ] ”用于表示要匹配的字符所属的字符集合。可以将所有可能匹配到的字符枚举出来，如：```[ios789] 可以匹配到 i 或者 o 或者 s 或者 7 或者 8 或者 9 。 也可以根据 ASCII码的顺序，将某个范围内的字符都包括在内，如上述的正则表达式等价于：123同时也能够在其中使用元字符，如：```[\\w,\\n] 可以匹配一个单词字符，或者一个逗号，或者一个换行符。 上述三个例子中，一次都只能匹配一个字符，如果要匹配多个字符，可以后接数量的修饰，如：12表示匹配两个或者三个字母；```[a-zA-Z]+ 表示匹配至少一个字母； 此外，也可以用1```[^0-9] 表示匹配一个数字以外的所有字符。 匹配定位点定位点能够将正则表达式固定到一行或整个字符串的起始位置或结尾。它们还能够创建匹配一个单词的开头、结尾或内部字符的表达式。 需要注意的是，定位点匹配到的并不是一个实际的字符，而只是一个位置。 例如，在表达式匹配单词边界。 该表达式与 “never” 中的 “er” 匹配，但与 “verb” 中的 “er” 不匹配。12345678910111213141516171819下表包含正则表达式定位点以及它们的含义：| 字符 | 说明 || --- | --- || ^ | 匹配输入字符串开始的位置。 如果标志中包括 m（多行搜索）字符，^ 还将匹配 \\n 或 \\r 后面的位置。 || $ | 匹配输入字符串结尾的位置。 如果标志中包括 m（多行搜索）字符，$ 还将匹配 \\n 或 \\r 前面的位置。 || \\b | 匹配一个字边界，即字与空格间的位置。 || \\B | 非字边界匹配。|### 子串的捕获使用括号可以捕获其中的子串，并将其保存作为变量，以用于后续的匹配或替换。假设正则表达式是一个小型计算机程序，那么捕获子串就是它输出的一部分。在实际使用中，可能会捕获很多子串，被捕获的子串从左向右编号，也就是只需要对左括号计数。引用时使用```\\x```的格式，子串编号从```\\1```开始，```\\0```表示原字符串本身。假设正则表达式如下： (\\w+) had a ((\\w+) \\w+)12那么对于字符串： I had a nice day12该正则表达式捕获到的子串如下： \\0: I had a nice day\\1: I\\2: nice\\3: nice day123456### 或正则表达式中允许对多个匹配选项之间进行分组，相当于“或”的作用。如正则表达式：```(Chapter|Section) [1-9][0-9]&#123;0,1&#125; 在匹配字符串：3 Section 90```1时，可以匹配到 ```Chapter``` 和 ```Section Objective-C 中的正则表达式Objective-C 中有专门的一个正则表达式类 —— NSRegularExpression，使用较为方便。此外在 NSPredicate 中也支持用正则表达式进行查询。OC 头文件中的注释对它们的具体用法作了详细的介绍，本文就再赘述了。 值得注意的是，OC 中的正则表达式中，匹配到的子串是用123456## 示例### 将表格替换为 Markdown 格式上文中从维基百科上拷贝下来的表格: 字符 描述\\ 将下一个字符标记为一个特殊字符（File Format Escape）、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\”匹配“\\”而“(”则匹配“(”。^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。$ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 匹配前面的子表达式零次或多次。例如，zo能匹配“z”、“zo”以及“zoo”。等价于{0,}。 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。12Markdown 格式的表格: 字符 描述 \\ 将下一个字符标记为一个特殊字符（File Format Escape）、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\”匹配“\\”而“(”则匹配“(”。 \\^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，\\^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”、“zo”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 123匹配的正则表达式：``` ^(.*?)\\t(.*)$ 替换的正则表达式：\\1 | \\2 | ```12345678910111213141516171819202122232425262728293031323334### 美拍滤镜 plist 格式替换原格式：```xml&lt;dict&gt; &lt;key&gt;id&lt;/key&gt; &lt;integer&gt;3002&lt;/integer&gt; &lt;key&gt;inputSource&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;index&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;source&lt;/key&gt; &lt;string&gt;3002/gleam.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;晨露&lt;/string&gt; &lt;key&gt;nameEN&lt;/key&gt; &lt;string&gt;Shimmer&lt;/string&gt; &lt;key&gt;nameTW&lt;/key&gt; &lt;string&gt;微光&lt;/string&gt; &lt;key&gt;percent&lt;/key&gt; &lt;real&gt;0.7&lt;/real&gt; &lt;key&gt;shaderType&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;statisticsId&lt;/key&gt; &lt;string&gt;fli3002&lt;/string&gt; &lt;key&gt;thumb&lt;/key&gt; &lt;string&gt;gleam2.png&lt;/string&gt;&lt;/dict&gt; 目标格式: 12345678910111213141516171819&lt;dict&gt; &lt;key&gt;ColorFilter&lt;/key&gt; &lt;integer&gt;58&lt;/integer&gt; &lt;key&gt;ColorFilterConfigPath&lt;/key&gt; &lt;string&gt;preFilters/3030/filterConfig.plist&lt;/string&gt; &lt;key&gt;Icon&lt;/key&gt; &lt;string&gt;perfume2.png&lt;/string&gt; &lt;key&gt;MVID&lt;/key&gt; &lt;string&gt;fli3030&lt;/string&gt; &lt;key&gt;Title&lt;/key&gt; &lt;string&gt;嘉年华&lt;/string&gt; &lt;key&gt;TitleTranslation&lt;/key&gt; &lt;dict&gt; &lt;key&gt;zh-Hant&lt;/key&gt; &lt;string&gt;嘉年華&lt;/string&gt; &lt;key&gt;en&lt;/key&gt; &lt;string&gt;Carnival&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt; 查找的正则表达式：1&lt;dict&gt;[\\w|\\W]*?&lt;key&gt;name&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;\\W+&lt;key&gt;nameEN&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;\\W+&lt;key&gt;nameTW&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;[\\w|\\W]*?&lt;key&gt;statisticsId&lt;/key&gt;\\W+&lt;string&gt;([a-zA-Z]+([0-9]+))&lt;/string&gt;\\W+&lt;key&gt;thumb&lt;/key&gt;\\W+&lt;string&gt;([\\w|\\W]*?)&lt;/string&gt;\\W+&lt;/dict&gt; 替换的正则表达式：1&lt;dict&gt;\\n&lt;key&gt;ColorFilter&lt;/key&gt;\\n&lt;integer&gt;58&lt;/integer&gt;\\n&lt;key&gt;ColorFilterConfigPath&lt;/key&gt;\\n&lt;string&gt;preFilters/\\5/filterConfig.plist&lt;/string&gt;\\n&lt;key&gt;Icon&lt;/key&gt;\\n&lt;string&gt;\\6&lt;/string&gt;\\n&lt;key&gt;MVID&lt;/key&gt;\\n&lt;string&gt;\\4&lt;/string&gt;\\n&lt;key&gt;Title&lt;/key&gt;\\n&lt;string&gt;\\1&lt;/string&gt;\\n&lt;key&gt;TitleTranslation&lt;/key&gt;\\n&lt;dict&gt;\\n&lt;key&gt;zh-Hant&lt;/key&gt;\\n&lt;string&gt;\\3&lt;/string&gt;\\n&lt;key&gt;en&lt;/key&gt;\\n&lt;string&gt;\\2&lt;/string&gt;\\n&lt;/dict&gt;\\n&lt;/dict&gt; ###歌词信息读取 歌词文件的样式（尖括号中为时间戳，后接一段歌词）： 1&lt;0,626&gt;killing &lt;627,626&gt;spring&lt;627,626&gt;kill ing&lt;627,626&gt;我是一段 歌词### &lt;627,626&gt;我是一句歌词~ ~~ 用于匹配的正则表达式： 1&lt;([0-9]+),([0-9]+)&gt;([\\w|\\W]+?)(?=&lt;|$) 可以将匹配到的子串转换为 JSON 格式： 1&#123;\\n&quot;stamp1&quot;: \\1,\\n&quot;stamp2&quot;: \\2,\\n&quot;content&quot;: \\3\\n&#125;,\\n","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://punmy.cn/tags/正则表达式/"},{"name":"技能","slug":"技能","permalink":"http://punmy.cn/tags/技能/"}]},{"title":"iOS Search APIs","slug":"15158218121366","date":"2017-03-06T08:40:00.000Z","updated":"2018-04-07T10:51:43.000Z","comments":true,"path":"2017/03/06/15158218121366.html","link":"","permalink":"http://punmy.cn/2017/03/06/15158218121366.html","excerpt":"IntroduceiOS 9 之后，Apple 开放了三大 Search APIs，以便用户能在 Spotlight、Safari 等搜索入口，搜索到应用中的内容，这十分有助于提升应用的用户活跃度。","text":"IntroduceiOS 9 之后，Apple 开放了三大 Search APIs，以便用户能在 Spotlight、Safari 等搜索入口，搜索到应用中的内容，这十分有助于提升应用的用户活跃度。 这三组 Search APIs 分别是： NSUserActivity：能够为用户在 App 中的历史活动建立索引，例如到达某个关键页面，或是浏览到某个内容页。以便以后用户能够通过搜索结果恢复到该页面。 Core Spotlight：为 App 中的一些重要内容，在设备上建立索引，以提供快速入口。 Web markup：关联服务器上的内容到搜索结果中，用户即使没有安装 App，也能在搜索结果中看到相关内容。 本文主要介绍前两种 API —— NSUserActivity 和 Core Spotlight。 Note: 虽然全局搜索（app search）功能在 iOS 9 后就可用了，但是实际上，部分旧机型仍然不支持 NSUserActivity 和 Core Spotlight 的搜索功能，如 iPhone 4s、iPad 2、iPad（第三代）、iPad mini，以及 iPod touch 5. Core Spotlight Index App Content Core Spotlight 主要用于为 App 中的一些重要内容（比较静态），在设备上建立索引。例如，应用的一些常用功能页面，以及一些文档、音视频内容，以便用户能够很方便地访问这些常用内容。 使用前需要 import Core Spotlight。 1、建立索引索引对应的类是CSSearchableItem。建立索引前，要先创建索引的属性集CSSearchableItemAttributeSet。 CSSearchableItemAttributeSet中包含了大量的属性，包括音视频信息、文件信息、出版信息、联系人信息等等。实例化属性集时，就要指定属性集的类型，如kUTTypeImage，这会影响到索引的显示样式。这些常量声明于MobileCoreServices.UTCoreTypes中，因此需要 import 这个头文件。属性集中比较常用的属性为 title、contentDescription 和 keywords，title 就是索引显示的标题，contentDescription 是对内容的描述，keywords 则是索引的关键词数组，官方建议关键词为 5 个左右。需要注意的是，title 默认就能被搜索到，不需要加入 keywords。 设置完索引的属性集之后，就可以通过CSSearchableItem的init(uniqueIdentifier: domainIdentifier: attributeSet:)来实例化一个索引。其中，参数uniqueIdentifier是该索引的唯一标识符，可以通过这个标识符来删除这条索引；domainIdentifier是索引所在的域名标识，域名标识可以用于将索引分类存放，可以根据它来删除同一个domainIdentifier下的所有索引。 接下来便是建立索引。建立索引需要调用CSSearchableIndex实例的indexSearchableItems()方法。它能够批量建立索引，并提供一个回调。 12345678910111213141516171819202122232425262728293031323334func createSearchIndex(with followers: [User]) &#123; if #available(iOS 9.0, *) &#123; var searchableItems = [CSSearchableItem]() users.forEach &#123; (follower) in // 索引的属性集（只用于控制索引在被搜索时的属性，不能存储数据） let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeImage as String) // 索引的标题（标题也能被搜索到） attributeSet.title = follower.name // 索引的描述 attributeSet.contentDescription = \"我的爱豆\" // 用于建立索引的关键词 attributeSet.keywords = [\"punmy\", \"爱豆\", follower.identifier] // Spotlight 索引的类 let searchableItem = CSSearchableItem(uniqueIdentifier: \"punmy://user?id=\\(follower.identifier)\", domainIdentifier: \"com.meitu.yy.followers\", attributeSet: attributeSet) searchableItems.append(searchableItem) &#125; CSSearchableIndex.default().indexSearchableItems(searchableItems, completionHandler: &#123; (error) in if let error = error &#123; DDLogError(\"Create searchable index failed, error: \\(error.localizedDescription)\") &#125; &#125;) &#125;&#125;func cleanSearchIndex() &#123; if #available(iOS 9.0, *) &#123; // 删除整个域名标识下的索引 CSSearchableIndex.default().deleteSearchableItems(withDomainIdentifiers: [\"com.punmy.followers\"]) &#123; (error) in if let _ = error &#123; DDLogError(\"delete searchable items failed, error: \\(error?.localizedDescription)\") &#125; &#125; &#125;&#125; 调用indexSearchableItems()方法成功后，就能立即在 Spotlight 中搜索到刚刚添加的索引了。 通过 CSSearchableIndex 实例的几个删除方法，就能部分，或者全部删除索引。 2、实现回调要处理从搜索结果中进入 App 的回调事件，需要在 AppDelegate 中实现application:continueUserActivity:restorationHandler:方法。这个回调在许多地方都会用到，如 Core Spotlight、Siri Kit、Handoff 等。可以在这个页面中，利用 userActivity 的 userInfo 字典中的数据，跳转到相应的页面。 Note：值得注意的是，之前我们为userActivity所设置的属性集，在这里都不存在了。只有保存在 userInfo 中的数据，才能在这个回调中获取到。 之前创建CSSearchableItem时传入的uniqueIdentifier参数，在此处可以通过 userInfo 中的 CSSearchableItemActivityIdentifier key值读取到，可以参考一下代码。 123456789func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -&gt; Void) -&gt; Bool &#123; if #available(iOS 9.0, *) &#123; if let identifier = userActivity.userInfo?[CSSearchableItemActivityIdentifier] as? String &#123; // 跳转到对应页面 restoreActivity(scheme: identifier) &#125; &#125; return true&#125; 上文我们已经提到过，有许多功能的回调入口都是这个方法，那么如何区分不同入口呢？一种办法是像上方代码一样，判断userInfo中是否存在 key 为CSSearchableItemActivityIdentifier的值；另一种办法可以判断userActivity的 activityType属性的值，是否为CSSearchableItemActionType。 在某些功能中，userActivity 的 activityType 是设置为自定义域名的，如下面将会讲到 NSUserActivity 部分。但在 Core Spotlight 中，所有的索引的类型都被系统设置为CSSearchableItemActionType。 NSUserActivity Index Activities and Navigation Points NSUserActivity 主要用于为用户在 App 中的历史活动建立索引。NSUserActivity 的作用有些类似于浏览器中的“历史记录”，只是记录的内容是由我们来决定的。NSUserActivity 可以配合 Handoff 一起使用，以便在其他设备上继续当前活动，有关 Handoff 可以参照：Handoff 介绍。 我们可以在用户使用 App 的时候，将他浏览过的一些关键节点，或是重要的内容页面，在系统中建立一个索引，保存必要的数据。日后用户在 Spotlight 等地方搜索相关内容时，就能在搜索结果中显示该活动记录（UserActivity）。当用户点击该搜索结果时，系统会调起 App，并传入之前保存的数据，应用就能以此来恢复现场。 1、建立索引首先，我们需要在用户浏览到某些页面的时候，将该页面加入系统索引。例如在 viewDidLoad（）的时候： 123456789101112131415161718192021222324252627282930313233343536373839// MARK: - Indexing activity let uservar activity? // 务必对 Activity 进行强引用 override func viewDidLoad() &#123; super.viewDidLoad() let activity = NSUserActivity(activityType: \"com.meitu.punmy.user\") // 索引的标题 activity.title = user.name if #available(iOS 9.0, *) &#123; // 索引的属性集（只影响搜索结果的显示样式，不能用于存储数据） let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeContact as String) // 索引的描述 attributeSet.contentDescription = user.desc // 能被搜索到的关键词（索引的标题也能被搜索到） attributeSet.keywords = [user.identifier, \"punmy\"] // 与项目本身的 scheme 搭配使用，便于跳转 let scheme = \"punmy://user?id=\\(user.identifier)\" // 关联已有的 SpotLight Item attributeSet.relatedUniqueIdentifier = scheme activity.contentAttributeSet = attributeSet // 只有 userInfo 中能够保存数据 activity.userInfo = [\"scheme\": scheme] // 是否建立索引 activity.isEligibleForSearch = true // 是否支持 Handoff 功能 activity.isEligibleForHandoff = false // 索引的过期时间，默认一个月 activity.expirationDate = Date(timeIntervalSinceNow: 7 * 24 * 60 * 60) &#125; // 激活 Activity activity.becomeCurrent() // 必须对 Activity 进行强引用，否则 Activity 很可能不会被加入索引 self.activity = activity&#125; 要完成这个任务，我们先要创建一个 NSUserActivity对象，用于保存当前页面的一些必要信息，以及要建立的索引的一些属性。 创建 NSUserActivity 对象时，需要传入一个初始化参数activityType，这个activityType类似于 Core Spotlight 中的域名标识，只是作用上有些区别。在 Spotlight 等入口，搜索结果被点击时，系统会根据这个标识，去区分由哪个应用来恢复这个活动。在进入应用后，我们也能够在回调中，利用这个属性来区分活动。 为了让系统知道我们的应用能处理哪些 activityType，我们也需要在 Info.plist 中，创建一个名为NSUserActivityTypes的 String 数组，标识出所有我们的应用能够处理的 activityType。 通过设置 NSUserActivity的contentAttributeSet属性，我们可以自定义索引在搜索结果中的样式。设置给contentAttributeSet属性的是一个CSSearchableItemAttributeSet实例，与 Core Spotlight 中的属性集相似，它包含大量的属性可以设置。 Note：Activity 在调用了 becomeCurrent() 方法激活后，必须对 Activity 进行强引用，防止它 dealloc 了，否则 Activity 很可能不会被加入索引。相关讨论见 Apple 论坛：Search APIs are working 2、实现回调NSUserActivity 的回调入口与 Core Spotlight 的很相似。同样在AppDelegate中实现application:continueUserActivity:restorationHandler:方法，像上面说到的，我们可以通过 userActivity 的 activityType 属性来区分活动类型。此时userActivity的属性集也已经为空，只能访问到 userInfo 中的数据。 123456func application(UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: [AnyObject]? -&gt; Void) -&gt; Bool &#123; if userActivity.activityType == \"com.meitu.punmy.user\" &#123; // Restore app state for this userActivity and associated userInfo value. &#125; return true&#125; Web markup Engage Web Content 由于本次分享的主要针对 Core Spotlight 和 NSActivity，Web markup 就只作简要介绍。 Web Markup允许应用将它们的内容映射到一个网站（如网页版美拍），从而在 Spotlight 或 Safari 中进行搜索，即使用户没有安装相关应用。用户点击相关结果后，如果没有安装应用，则通过 Safari 打开，如果已经安装应用，则跳转到对应页面。 苹果有类似于搜索引擎爬虫的机器人，能够抓取支持 Web markup 的网站来获取所需的信息（需要后台配置，并结合 Universal Link 使用）。抓取结果会储存在苹果的云索引服务器上，通过 Safari 和 Spotlight 提供给用户。 有关 Web markup 的详细内容可以访问官方文档：Mark Up Web Content 联合使用 Core Spotlight 和 NSUserActivity苹果在官方文档中表示，三大搜索 API 是为了联合使用而设计的，混合使用多种 API 有助于提升搜索的覆盖率。但在实际使用中，混合使用多种 API 会有一些坑，下面大致讲一下一些注意事项。 ###1、唯一标识的使用###Core Spotlight 中的 uniqueIdentifier，NSUserActivity 中的 relatedUniqueIdentifier 属性，以及 Web markup 中的 webpageURL，都会被系统用于索引的关联。但系统不会平等地处理这几个东西。 例如，如果我们分别通过 Core Spotlight 和 NSActivity 生成了两个相同标识的索引/活动，那么在 Spotlight 中搜索到的只会是通过 Core Spotlight 设置的索引；而 NSActivity 生成的索引，则是用于 Siri Kit（如果你有使用 Siri Kit 的话）。 ###2、索引的更新和删除###通过 Core Spotlight 建立的索引，可以通过 CSSearchableIndex 实例的三个删除方法进行删除。也可以设置过期时间，由系统自动清除。默认的过期时间为一个月。而通过 NSActivity 生成的索引，只能设置过期时间，由系统管理，无法手动删除。 要更新相同 API 建立的索引，只需要再建立一个相同 identifier 的索引或者活动，系统就会自动更新对应索引。但是，不同 API 生成的索引，即使 identifier 相同，也不会相互更新内容。 ###3、搜索排序###苹果对于搜索的排序主要依据以下几个维度： 用户浏览 App 中内容的频率 (当我们调用 NSUserActivity 的becomeCurrent()方法时，系统会进行统计) 用户对于应用中的内容的参与度（由“互动率”决定。“互动率”是基于两个数据计算的，分别是：用户点击与你应用相关的条目的次数，以及搜索结果中显示的应用相关的条目的数量） 你的网站中某个网址的受欢迎程度，以及可用的结构化数据量。（Web markup） 坊间传闻，苹果为了防止世界被破坏，守护 iOS 的生态圈，在搜索结果的排序上，花费了重金进行优化。没有好好维护 iOS 生态圈的话，可能会导致应用的索引被降低排名，或是被踢出搜索结果。因此在使用搜索 API 时，我们需要注意： 防止过度索引；（不要把一大堆有的没的数据，都丢到系统索引中去） 尽快将用户带入内容页；（避免中间步骤，以及降低 App 启动时间） 如果创建的 NSUserActivity 与已有的 Core Spotlight 索引相同，那么就将它们用相同的 identifier 关联起来，这样每次激活 NSUserActivity 时，也能提升 Core Spotlight 索引的排名； END使用 Search APIs 可以有效提升应用的用户体验，但要注意各种 API 的适用场景，同时维护好 iOS 的生态圈。 参考官方文档：App Search Programming Guide","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"基础","slug":"基础","permalink":"http://punmy.cn/tags/基础/"},{"name":"framework","slug":"framework","permalink":"http://punmy.cn/tags/framework/"}]},{"title":"OSX/iOS 网络抓包工具 Charles 入门","slug":"14757432517519","date":"2016-10-06T08:40:00.000Z","updated":"2018-04-07T10:08:11.000Z","comments":true,"path":"2016/10/06/14757432517519.html","link":"","permalink":"http://punmy.cn/2016/10/06/14757432517519.html","excerpt":"在 iOS 开发中，我们常常要涉及到网络编程，而网络编程中的调试往往令人头痛。此外，我们也有时也会需要抓取一些 App 的网络包，以便了解它网络请求的API。本篇要介绍的 Charles 就是一款非常好用的网络调试工具，它可以轻松地满足我们的上述需求。","text":"在 iOS 开发中，我们常常要涉及到网络编程，而网络编程中的调试往往令人头痛。此外，我们也有时也会需要抓取一些 App 的网络包，以便了解它网络请求的API。本篇要介绍的 Charles 就是一款非常好用的网络调试工具，它可以轻松地满足我们的上述需求。 本篇博客中所使用的环境为：macOS Sierra 10.12，Charles 4.0.1，iPod Touch 5。 准备工作启动 CharlesCharles 的下载安装这里就不再赘述。启动 Charles 后，我们可以看到 Charles 的主界面。 窗口的左侧是抓取到的网络包，通常 Charles 启动后我们就可以看到 Mac 上的一些网络包开始出现在这里。 窗口右侧是选中的网络包的详细信息，如 URL、状态码等。 窗口上方是一些常用的工具。鼠标经过时就会有相应的提示，后面再细说。 右下角是 Charles 当前的状态。可以显示 Recording、BreakPoints、Rewrite 等功能是否启用。 连接设备要抓取 iOS 设备上的网络包，首先要将 iOS 设备和装有 Charles 的电脑连接到同一个局域网下，并将 Charles 设置为 iOS 的 HTTP 代理，这样 Charles 就可以捕捉到所有进出 iOS 的网络包。设置的步骤如下： 确保装有 Charles 的 mac 和等待调试的 iOS 设备在同一局域网内； 查找 mac 的 IP 地址（可以在 Charles 菜单栏的 Help -&gt; Local IP Address 直接查看）； 在 iOS 设备上的 设置 -&gt; Wi-Fi 中，点击已连接 WiFi 右侧的 详细按钮（蓝色），将 WiFi 详情页底部的 HTTP 代理 设为手动，并在 服务器 一栏填入上一步中 mac 的 IP 地址，在 端口 一栏填入 Charles 的默认代理端口 8888，然后退出设置； 此时如果网络正常的话，Charles 会提示有设备企图连接，同意连接，便完成了代理的设置。 注意：许多公司的内部局域网会限制设备间的互相访问，这可能会导致 Charles 抓取不到网络包，这种情况下可以尝试自己创建一个热点。 连接完成后，窗口左侧开始出现 Charles 抓到的包，说明进展顺利。 抓包捕获Charles 启动后，就处于 Recording 状态，会自动捕捉网络包，点击窗口上方工具栏的第二个按钮可以停止捕捉。 在窗口左侧的选择上方的 Structure 或 Sequence 可以切换网络包的显示方式。 Structure 是根据主机名以树状显示，便于查看同一主机名的网络包，每当有新的请求到达时，相应的主机名就会用黄色高亮闪烁。我们通常都是采用这个方式。 Sequence 则是根据网络请求的时间顺序依次显示，在这个模式下，整个窗口的布局也会有所变化。 选中某个网络包后，右侧就会显示该网络包的详细信息。 开始抓包之后，我们会发现，只有 HTTP 的包被成功解析了，HTTPS 的包都处于加密状态。要想查看 HTTPS 的包内容，可以查看本文中 SSL 代理的小节。 过滤开始抓包后，随着时间的推移，抓取到的网络包越来越多，这是我们可以使用过滤功能，来过滤出我们想要的网络请求。 在 Proxy -&gt; Recording Settings 中可以设置网络包的过滤选项。 过滤选项中有 Include 和 Exclude 两种选项。只有当 Include 为空时，Exclude 中的设置才会生效。过滤条件支持通配符。 修改网络包修改历史请求可以将历史的请求修改后，再次发送。 只需选中某个请求，点击上方工具栏中的蓝色钢笔按钮（第四个），就可以进行修改。完成修改后，点击下方的 Execute 执行请求。 断点窗口上方的工具栏中，第四个按钮就是 Enable BreakPoints，用来启用或禁用断点。也可以在 Proxy -&gt; BreakPoints Setting 中设置更多具体内容。 在 Charles 中可以像调试程序一样添加断点。方法是右键点击左侧窗口的某个请求，选择 BreakPoints 添加断点。这样当这个请求发出或者收到 response 的时候，就会先被 Charles 拦截下来，并触发断点。 触发断点后，可以对断点的网络包进行各种编辑，然后再继续。点击 Execute 就可以继续。 同时，也可以在 Proxy -&gt; BreakPoints Setting 设置断点的各种规则。例如，是在 request 的时候触发还是 response 的时候。 由于设置断点时，Charles 是先拦截下整个网络包，再触发断点，当网络包比较大的时候，常常会导致应用超时，触发网络错误的警告，因此，自动地根据规则修改网络包有时显得尤为重要。这就是下面要说的篡改。 篡改（Rewrite）Rewrite 是按照一组事先设置的规则，篡改特定的网络包中的数据。 在 Tools -&gt; Rewrite 中，选中 Enable Rewrite 来开启 Rewrite。 勾选 Debug in Error Log 选项，就能在 Charles 控制台中看到 Rewrite 的记录。 首先要在右侧的规则列表中添加一个新规则。在新规则中添加要 Rewrite 的 Location，然后再下方添加具体的篡改规则。规则中可以使用通配符。 这样稍后匹配条件的网络包到达的时候，Charles 就会自动将其中的内容按规则篡改。 映射Charles提供的映射功能可以将本地文件或者远程的服务器作为某个请求的 Response。可以方便地进行一些特殊的测试。 Map Local本地映射，在 Tools -&gt; Map Local。可以选择一个本地文件作为某个请求的 Response，并且 Charles 会帮你封装好 Response。 Remote Remote远程映射和本地映射的功能类似，只是将数据源换成了远程服务器。相当于将请求交给另一个服务器处理 网络环境模拟Charles 还可以模拟不同网速环境，可以很方便地测试应用在网络差的情况下的 bug。 在 Proxy -&gt; Throttle Settings 中勾选 Enable Throttling，或者直接点击窗口上方的工具栏中的乌龟🐢按钮就可以启用，这个按钮十分形象。 在 Proxy -&gt; Throttle Settings 中，添加要针对的 Locations，如果选中了 Only for selected hosts，并且Locations中有数据，则只有 Locations 列表中的请求会被限速，否则会对全局限速。在 Throttle Configuration 中可以对网络环境进行十分详细的配置，包括网络的稳定程度、网速、环境等。 SSL 代理在使用 Charles 的过程中，我们会发现，只有未加密的 Http 请求才能被 Charles 正确的解析出数据，其余的 Https 请求都处于加锁的状态，但我们不可避免的需要抓取 Https 的包。SSL 代理就可以完美解决这个问题。 要启用 SSL 代理，先要在 Proxy -&gt; SSL Proxying Settings 中勾选 Enable SSL Proxying，然后配置要代理的 Location，一般可以直接填星号，以匹配所有请求。 接下来还要安装 Charles 的证书。 Charles 中的 HTTPS 代理的原理是，Charles 充当一个中间人，针对目标服务器动态地生成一个使用 Charles 根证书（Charles CA Certificate）签名的证书；请求发生的时候， Charles 会接收 web 服务器的证书，而把自己生成的证书给客户端看。 因此在在使用 Charles 作为 HTTPS 代理时，客户端在请求 HTTPS 接口的时候会弹出安全警告，提示 Charles 根证书不被信任。我们需要添加 Charles 根证书为信任证书中。 方法如下： 1、点击 Help -&gt; SSL Proxying，根据被抓包设备的类型，来选择对应的安装选项（如果是 OSX 就直接选择 Install Charles Root Certificate）； 2、如果是iOS真机，则会弹出下面的提示，此时不用按上面的提示来配置代理，只要按照上文的步骤配置过代理了就可以了。然后在 Safari 中打开 chls.pro/ssl 安装 Charles 的证书，就 OK 了。 设置好 SSL 代理后，HTTPS 请求就统统解锁啦！ Charles 是一个强大的抓包调试工具，它的功能远不止这些，但本篇作为一篇入门的博客，就先介绍这么多啦，更多功能等待大家探索~ 套餐PostmanCharles 搭配 Postman 更好用噢~Postman 是 Chrome 浏览器中的一个小应用，可以在 Chrome 应用商城中找到。是居家旅行测试 Web API 的好帮手！","categories":[{"name":"工具","slug":"工具","permalink":"http://punmy.cn/categories/工具/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://punmy.cn/tags/网络/"},{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"工具","slug":"工具","permalink":"http://punmy.cn/tags/工具/"}]},{"title":"心跳之旅—💗—iOS用手机摄像头检测心率(PPG)","slug":"15231176397746","date":"2016-07-28T12:56:00.000Z","updated":"2018-04-07T17:04:26.000Z","comments":true,"path":"2016/07/28/15231176397746.html","link":"","permalink":"http://punmy.cn/2016/07/28/15231176397746.html","excerpt":"[前情提要] 光阴似箭，日月如梭，最近几年，支持心率检测的设备愈发常见了，大家都在各种测空气测雪碧的，如火如荼，于是我也来凑一凑热闹。[0]这段时间，我完成了一个基于iOS的心率检测Demo，只要稳定地用指尖按住手机摄像头，它就能采集你的心率数据。Demo完成后，我对心率检测组件进行了封装，并提供了默认动画和音效，能够非常方便导入到其他项目中。在这篇博客里，我将向大家分享一下我完成心率检测的过程，以及，期间我遇到的种种困难。","text":"[前情提要] 光阴似箭，日月如梭，最近几年，支持心率检测的设备愈发常见了，大家都在各种测空气测雪碧的，如火如荼，于是我也来凑一凑热闹。[0]这段时间，我完成了一个基于iOS的心率检测Demo，只要稳定地用指尖按住手机摄像头，它就能采集你的心率数据。Demo完成后，我对心率检测组件进行了封装，并提供了默认动画和音效，能够非常方便导入到其他项目中。在这篇博客里，我将向大家分享一下我完成心率检测的过程，以及，期间我遇到的种种困难。 本文中涉及到的要点主要有： AVCapture Core Graphics Delegate &amp; Block RGB -&gt; HSV 带通滤波 基音标注算法（TP-Psola） 光电容积脉搏波描记法（PhotoPlethysmoGraphy, PPG） 在开始之前，我先为大家展示一下最后成品的效果： 上图展示的是心率检测过程中的主要界面。在检测的过程中，应用能够实时捕捉心跳的波峰，计算相应的心率，并以Delegate或Block的形式回调，在界面上显示相应的动画和音效。 ##〇、剧情概览 好吧，😂其实上面的前情提要都是我瞎掰的，这个Demo是我来到公司的第一天接到的任务。刚接到任务的时候其实是有点懵逼的，原本以为刚入职两天可能都是要看看文档，或者拖拖控件，写写界面什么的，结果Xcode都还没装好，突然接到一个心率检测的任务，顿时压力就大起来了😨，赶紧拍拍屁股起来找资料。 心率检测的APP在我高三左右就有了，我清楚地记得当时，年少无知的我还误以为，大概又是哪个刁民闲着无聊恶搞的流氓应用，特地下载下来试了一下，没想到居然真的能测。。。当时就震惊地打开了某度查了这类应用的原理。所以现在找起资料来还是比较有方向性的。 花了一天的时间找资料，发现在手机心率检测方面，网上相关的东西还是比较少。不过各种资料参考下来，基本的实现思路已经有了。 任务清单 实现心率检测 一、整体思路原理首先说一说用手机摄像头实现心率检测所用到的原理。我们知道，现在市面上有非常多具备心率检测功能的可穿戴设备，比如各种手环以及各种Watch，其实从本质上讲，我们这次要用到的原理跟这些可穿戴设备所用到的原理并无二致，它们都是基于光电容积脉搏波描记法（PhotoPlethysmoGraphy, PPG）。 PPG是追踪可见光（通常为绿光）在人体组织中的反射。它具备一个可见光光源来照射皮肤，再使用光电传感器采集被皮肤反射回来的光线。PPG有两种模式，透射式和反射式，像一般的手环手表这样，光源和传感器在同一侧的，就是反射式；而医院中常见的夹在指尖上的通常是透射式的，即光源和传感器在不同侧。皮肤本身对光线的反射能力是相对稳定的，但是心脏泵血使得血管容积周期性地变化，导致反射光也呈现出周期性的波动值，特别是在指尖这种毛细血管非常丰富的部位，这种周期性的波动很容易被观察到。 使用iPhone的系统相机就可以轻易地用肉眼观察到这种波动——在录像中打开闪光灯，然后用手指轻轻覆盖住摄像头，就能观察到满屏的红色图像会随着心跳产生一阵一阵的明暗变化，如下图（请忽略满屏的摩尔纹）。 至于，为什么可穿戴设备上用的光源大多数都是绿光，我们用手机闪光灯的白光会不会有问题。这主要是因为绿光在心率检测中产生的信噪比比较大，有利于心率的检测，用白光也是完全没问题的。详情可以移步知乎：各种智能穿戴的心率检测功能 。我在这里就不细说了。 我的思路我们已经知道我们需要用闪光灯和摄像头来充当PPG的光源和传感器，那么下面就来分析一下后续整体的方案。下面是我搜集完数据之后大致画出的一个流程图。 首先我们需要采集相机的数据，这一步可以使用AVCapture； 然后按照某种算法，对每一帧图像计算出一个相应的特征值并保存到数组中，算法可以考虑取红色分量或者转换为HSV再计算； 在得到一定量的数据后，我们对这个时间段内的数据进行预处理，譬如进行滤波，过滤掉一些噪声，可以参考一篇博客：巴特沃斯滤波器； 接下来，就可以进行心率计算，这一步可能涉及到一些数字信号处理的内容，例如波峰检测，信号频率计算，可以使用Accelerate.Framework的vDSP处理框架，Accelerate框架的用法可以参考：StackOverFlow的一个回答（最终我并没有使用，原因后面会提到）； 最终就可以得到心率。 二、初步实现有了大概的方案之后，我决定着手进行实现了。 1）视频流采集我们前面已经提到，我们要用AVCapture进行视频流的采集。在使用AVCapture的时候，需要先建立AVCaptureSession，相当于是一个传输流，用来连接数据的输入输出，然后分别建立输入和输出的连接。因此，为了更加直观，我先做了一个类似于相机的Demo，把AVCapture采集到的相机图像直接传输到一个Layer上。 创建AVCaptureSessionAVCaptureSession的配置过程类似于一次数据库事务的提交。开始配置前必须调用[_session beginConfiguration];来开始配置；完成所有的配置工作后，再调用[_session commitConfiguration];来提交此次配置。因此，整个配置过程大致是这样的： /** 建立输入输出流 */ _session = [AVCaptureSession new]; /** 开始配置AVCaptureSession */ [_session beginConfiguration]; /* * 配置session * （建立输入输出流） * ... */ /** 提交配置，建立流 */ [_session commitConfiguration]; /** 开始传输数据流 */ [_session startRunning]; 建立输入流From Camera要从相机建立输入流，就得先获取到照相机设备，并且对它进行相应的配置。这里对照相机的配置最关键的是要打开闪光灯常亮。此外，再设置一下白平衡、对焦等参数的锁定，来保证后续的检测过程中，不会因为相机的自动调整而导致特征值不稳定。 /** 获取照相机设备并进行配置 */ AVCaptureDevice *device = [self getCameraDeviceWithPosition:AVCaptureDevicePositionBack]; if ([device isTorchModeSupported:AVCaptureTorchModeOn]) { NSError *error = nil; /** 锁定设备以配置参数 */ [device lockForConfiguration:&amp;error]; if (error) { return; } [device setTorchMode:AVCaptureTorchModeOn]; [device unlockForConfiguration];//解锁 } 需要注意的是，照相机Device的配置过程中，需要事先锁定它，锁定成功后才能进行配置。并且，在配置闪光灯等参数前，必须事先判断当前设备是否支持相应的闪光灯模式或其他功能，确保当前设备支持才能够进行设置。此外，对于相机的配置，还有一点非常重要：记得调低闪光灯亮度！！ 长期打开闪光灯会使得电池发热，这对电池是一种伤害。在我调试的过程中，曾经无数次调着调着忘了闪光灯还没关，最后整只手机发热到烫手的程度才发现，直接进化成小米~ 所以，尽量将闪光灯的亮度降低，经过我的测试，即使闪关灯亮度开到最小也能够测得清晰的心率。 接下来就是利用配置好的device创建输入流： /** 建立输入流 */ NSError *error = nil; AVCaptureDeviceInput *deviceInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (error) { NSLog(@&quot;DeviceInput error:%@&quot;, error.localizedDescription); return; } 建立输出流 To AVCaptureVideoDataOutput建立输出流需要用到AVCaptureVideoDataOutput类。我们需要创建一个AVCaptureVideoDataOutput类并设置它的像素输出格式为32位的BGRA格式，这似乎是iPhone相机的默认格式（经@熊皮皮提出，除了这种格式，还有两种YUV的格式）。后续我们读取图像Buffer中的像素时，也是按照这个顺序（BGRA）去读取像素点的数据。设置中需要用一个NSDictionary来作为参数。我们还要设置AVCaptureVideoDataOutput的代理，并创建一个新的线程（FIFO）来给输出流运行。 /** 建立输出流 */ AVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new]; NSNumber *BGRA32PixelFormat = [NSNumber numberWithInt:kCVPixelFormatType_32BGRA]; NSDictionary *rgbOutputSetting; rgbOutputSetting = [NSDictionary dictionaryWithObject:BGRA32PixelFormat forKey:(id)kCVPixelBufferPixelFormatTypeKey]; [videoDataOutput setVideoSettings:rgbOutputSetting]; // 设置像素输出格式 [videoDataOutput setAlwaysDiscardsLateVideoFrames:YES]; // 抛弃延迟的帧 dispatch_queue_t videoDataOutputQueue = dispatch_queue_create(&quot;VideoDataOutputQueue&quot;, DISPATCH_QUEUE_SERIAL); [videoDataOutput setSampleBufferDelegate:self queue:videoDataOutputQueue]; 连接到AVCaptureSession建立完输入输出流，就要将它们和AVCaptureSession连接起来啦！这里需要注意的是，必须先判断是否能够添加，再进行添加操作，如下所示。 if ([_session canAddInput:deviceInput]) [_session addInput:deviceInput]; if ([_session canAddOutput:videoDataOutput]) [_session addOutput:videoDataOutput]; 实现代理协议的方法，获取视频帧上面的步骤中，我们将self设为AVCaptureVideoDataOutput的delegate，那么现在我们就要在self中实现AVCaptureVideoDataOutputSampleBufferDelegate的方法xxx didOutputSampleBuffer xxx，这样在视频帧到达的时候我们就能够在这个方法中获取到它。 #pragma mark - AVCaptureVideoDataOutputSampleBufferDelegate &amp; Algorithm - (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection { /** 读取图像Buffer */ CVPixelBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); // // 我们可以在这里 // 计算这一帧的 // 特征值。。。 // /** 转成位图以便绘制到Layer上 */ CGImageRef quartzImage = CGBitmapContextCreateImage(context); /** 绘图到Layer上 */ id renderedImage = CFBridgingRelease(quartzImage); dispatch_async(dispatch_get_main_queue(), ^(void) { [CATransaction setDisableActions:YES]; [CATransaction begin]; _imageLayer.contents = renderedImage; [CATransaction commit]; }); } 做到这里，我们已经获得了一个类似于相机的Demo，在屏幕上可以输出摄像头采集的画面了，接下来，我们就要在这个代理方法中对每一帧图像进行特征值的计算。 2）采样（计算特征值）采样过程中，最关键的就是如何将一幅图像转换为一个对应的特征值。我先将所有像素点转换为一个像素点（RGB）： 转换成一个像素点之后，我们只剩下RGB三个数值，事情就变简单得多。在设计采样的算法的过程中，我进行了许多种尝试。我先试着简单地使用R、G、B分量中的其中一个直接作为信号输入，结果都不理想。 - HSV色彩空间想到之前图形学的课上有介绍过HSV色彩空间，是将颜色表示为色相、饱和度、明度（Hue, Saturation, Value）三个数值。 我想，既然肉眼都能观察到图像颜色的变化，而RGB又没有明显的反映，那HSV的三个维度中应该有某个维度是能够反映出它的变化的。我便试着转换为HSV，结果发现色相H随脉搏的变化很明显！于是，我就先确定用H值来作为特征值。 我简单地用Core Graphics直接在图像的Layer上画出H数值的折线： 3）心率计算为了使得曲线更加直观，我对特征值稍做处理，又改变了一下横坐标的比例，得到如下截图。现在心率信号稳定以后，波峰已经比较明显了，我们开始进行心率的计算。 最初，我想到的是利用快速傅里叶变换（FFT）对信号数组进行处理。FFT可以将时域的信号转换成频域的信号，也就得到了一段信号在各个频率上的分布，这样，我们就能通过判断占比最大的频率，就差不多能确定心率了。但是可能由于我缺乏信号处理的相关知识，经过将近两天的研究，我还是看不懂跟高数课本一样的文档。。。于是我决定先用暴力的方法算出心率，等能用的Demo出来之后，看看效果如何，再考虑研究算法的优化。 通过上面的曲线，我们可以看出，在信号稳定的时候，波峰还是比较清晰的。因此我想，我可以设置一个阈值，进行波峰的检测，只要信号超过阈值，就判定该帧处于一个波峰。然后再设置一个状态机，完成波峰波谷之间的状态转换，就能检测出波峰了。因为从AVCapture得到的图像帧数为30帧，也就是说，每一帧代表1/30s的时间。那么我只需要数一数从第一个波峰到最后一个波峰之间，经过了多少帧，检测到了多少波峰，那么，就能算出每个波峰间的周期，也就能算出心率了。 这个想法非常简单，但是存在一个问题，那就是，阈值的设置。波峰的凸起程度并不是恒定的，有时明显，有时微弱。因此，一个固定的阈值肯定不能满足实际检测的需求。于是我想到我们可以根据心跳曲线波动的上下范围，来实时确定一个合适的阈值。我做了如下修改： 每次进行心率计算的时候，先找出整个数组的极大和极小值，确定数据上下波动的范围。然后，根据这个范围的一个百分比，来确定阈值。 也就是说，一个特征值只有超过了整组数据的百分之多少，它才会被判定为波峰。根据这个方法，我每隔一段时间对数据进行一遍检测，在Demo中实现了心率的计算，又对界面进行了简单的实现，大致的效果如下。 使用的过程中还存在一定程度的误检率，不过总算是实现了心率检测~ 🎉🎉🎉 三、性能优化在我粗略实现了心率检测的功能后，Leader提出了对性能进行优化的要求，顺便向我普及了一波Instruments的用法（以前我一直没有用过🙊）。 任务清单 性能优化 封装组件（delegate或block的形式）； 提供两种默认动画； 我用Instrument分析了心率检测过程中的CPU占用，发现占用率很高，维持在50%~60%左右。不过这在我的预料中，因为我的算法确实很暴力😂——每帧的图像是1920x1080尺寸的，在1/30秒内，要对这200多万个像素点进行遍历计算，还要转换成位图显示在layer上，隔一段时间还要计算一次心率。。。 我分析了CPU占用比较多的部分，归纳了几个可以考虑优化的方向 降低采样范围 降低采样率 取消AV输出 降低分辨率 改进算法，去除冗余计算 降低采样范围现在的采样算法是对所有的像素点进行一次采样，我想着是否能够缩小采样的范围，例如只对中间某块区域采样，但试验后我发现，只对某块区域采样会使得检测到的波峰变得模糊，说明个别区域的采样并不具有代表性。接着我又想到了一个新的办法。我发现图像中，临近像素点的颜色差异很小，那么我可以跳跃着采样，每隔几列、每隔几行采样一次，这样一方面可以减少工作量，一方面对采样的效果的影响也可以减少。 采样的方式就像上图展示的一样，再设置一个常量用来调节每次跳跃的间距。这样一来，理论上，每次占用的时间就可以降低为原来的1/n^2，大大减少。经过几次尝试后，可以看到，采样算法所在的函数的CPU占用比例由原来的31%降低到了14%了。 在分析CPU占用时，我发现在循环中对RGB分别累加时，第一个R的运算占用100倍以上的时间。开始时以为可能是Red分量数值较大，计算难度大，Leader建议我使用位运算，但是我改成位运算后，瓶颈依旧存在，弄得我十分困惑。后来我试着把RGB的计算顺序换一下，结果发现，瓶颈和R无关，不论RGB，只要谁在第一位，谁就会成为瓶颈。后来我想到，这应该是CPU和内存之间的数据传输造成的瓶颈，因为像素点都存在一块很大的内存块里，在取第一个数据的时候可能速度比较慢，然后后面取临近数据的时候可能就有Cache了，所以速度回提高两个数量级。 降低采样率降低采样率就是将视频的帧数降低，我记得，不知道是香农还是谁，有一个定理，大概的意思就是说，采样率只要达到频率的两倍以上，就能检测出信号的频率。（经coderMoe童鞋指出，此处正式名称为“奈奎斯特–香农采样定理”）人的心跳上限一般是160/分钟，也就是不到3Hz，那理论上，我们的采样率只要达到6帧/秒以上，就能够计算出频率。不过，由于我之前使用的算法还不是特别稳定，所以，当时我没有对采样率进行改变。 取消AV输出之前我为了方便看效果，将采集到的视频图像输出到了界面上的一层Layer上，其实这个画面完全没必要显示出来。因此我去除了这部分的功能，这样一来，整体的CPU占用就降低到了33%以下。 降低分辨率目前我们采集视频的大小是1920x1080，其实我们并不需要分辨率这么高。降低分辨率一方面可以减少需要计算的像素点，另一方面可以减少IO的时间。在我将分辨率降低到640x480： if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) { /** 降低图像采集的分辨率 */ [_session setSessionPreset:AVCaptureSessionPreset640x480]; } 结果非常惊人，整体的CPU占用率直接降低到了5%左右！ 改进算法，去除冗余计算最后，我对算法中一些冗余的计算进行了优化，不过，由于CPU占用已经降低到了5%左右，真正的瓶颈已经消除，所以这里的改进并没有很明显的变化。 四、封装此前，我们已经完成了一个大致可用的心率监测Demo，但在此之前，我着重考虑的都是如何尽快实现心率检测的功能，对整体的结构和对象的封装都没有太多的考虑，简直把OC的面向对象用成了面向过程。那么我们接下来的一个重要任务，就是对我们的心率检测进行封装，使它成为一个可复用的组件。 任务清单 封装组件并提供合理接口（delegate或block的形式）； 提供两种默认动画； 封装ViewController最开始的时候，我想到的是对ViewController进行封装，这样别人有需要心率检测的时候，就可以弹出一个心率监测的ViewController，上面带有一些检测过程中的动画效果，检测完成后自动dismiss，并且返回检测到的心率。我在protocol中声明了三个接口： /** * 心率检测ViewController的代理协议 */ @protocol MTHeartBeatsCaptureViewControllerDelegate &lt;NSObject&gt; @optional - (void)heartBeatsCaptureViewController:(MTHeartBeatsCaptureViewController *)captureVC didFinishCaptureHeartRate:(int)rate; - (void)heartBeatsCaptureViewControllerDidCancel:(MTHeartBeatsCaptureViewController *)captureVC; - (void)heartBeatsCaptureViewController:(MTHeartBeatsCaptureViewController *)captureVC DidFailWithError:(NSError *)error; @end 我将三个方法都设为了optional的，因为我还在ViewController中设置了三个相应的Block供外部使用，分别对应三个方法。 @property (nonatomic, copy)void(^didFinishCaptureHeartRateHandle)(int rate); @property (nonatomic, copy)void(^didCancelCaptureHeartRateHandle)(); @property (nonatomic, copy)void(^didFailCaptureHeartRateHandle)(NSError *error); 封装心率检测类对ViewController进行封装之后，我们可以看到，还是比较不合理的。这意味着别人只能使用我们封装起来的界面进行心率检测，如果使用组件的人有更好的交互方案，或者有特殊的逻辑需求，那他使用起来就会很不方便。因此，我们很有必要进行更深层次的封装。接下来，我将会剥离出心率检测的类，进行封装。 首先，我一点点剥离出心率检测的关键代码，放进新的MTHeartBeatsCapture类中。剥离的差不多之后，就发现满屏的代码都是红色的Error😲，花了一个下午，才把项目恢复到能运行的状态。 我在心率检测类中设置了两个方法：启动和停止。使用起来很方便。 /** 开始检测心率 */ - (NSError *)start; /** 停止检测心率 */ - (void)stop; 然后，我重新设计了一个心率检测器的回调接口，依旧是delegate和block并存的。新的接口如下： /** * 心率检测器的代理协议; * 可以选择Delegate或者block来获得通知, * 因此protocol中所有方法均为可选方法 */ @protocol MTHeartBeatsCaptureDelegate &lt;NSObject&gt; @optional /** 检测到一次波峰（跳动）,可通过返回值选择是否停止检测 */ - (BOOL)heartBeatsCapture:(MTHeartBeatsCapture *)capture heartBeatingWithRate:(int)rate; /** 失去稳定信号 */ - (void)heartBeatsCaptureDidLost:(MTHeartBeatsCapture *)capture; /** 得到新的特征值（30帧/秒） */ - (void)heartBeatsCaptureDataDidUpdata:(MTHeartBeatsCapture *)capture @end 我在新的接口中加入了heartBeatsCaptureDidLost:，方便在特征值波动剧烈的时候进行回调，这样外部就能提醒用户姿势不对。而第三个方法，则是为了之后外部的动画view能够做出类似于心电图一样的动画效果，而对外传出数据。我还移除了检测成功的回调didFinishCaptureHeartRate:，换成了heartBeatingWithRate:，把成功时机的判断交给了外部，当外部的开发人员认为检测的心率足够稳定了，就可以返回YES来停止检测。此外，我还移除了遇到错误的回调DidFailWithError:，因为我发现，几乎所有可能遇到的错误，都是发生在开始前的准备阶段，因此，我改成了在start方法中返回错误信息，并且枚举出错误类型作为code，封装成NSError。 typedef NS_OPTIONS(NSInteger, CaptureError) { CaptureErrorNoError = 0, /**&lt; 没有错误 */ CaptureErrorNoAuthorization = 1 &lt;&lt; 0, /**&lt; 没有照相机权限 */ CaptureErrorNoCamera = 1 &lt;&lt; 1, /**&lt; 不支持照相机设备，很可能处于模拟器上 */ CaptureErrorCameraConnectFailed = 1 &lt;&lt; 2, /**&lt; 相机出错，无法连接到照相机 */ CaptureErrorCameraConfigFailed = 1 &lt;&lt; 3, /**&lt; 照相机配置失败，照相机可能被其他程序锁定 */ CaptureErrorTimeOut = 1 &lt;&lt; 4, /**&lt; 检测超时，此时应提醒用户正确放置手指 */ CaptureErrorSetupSessionFailed = 1 &lt;&lt; 5, /**&lt; 视频数据流建立失败 */ }; 主要的工作完成后，Leader给我提了不少意见，主要还是封装上存在的一些问题，很多地方没有必要对外公开，应该尽可能地对外隐藏，接口也应该尽量地精简，没必要的功能要尽可能的去掉。特别是对外公开的一个特征值数组（NSMutableArray），对外应该不可变，这一点我一直没有考虑到。 封装动画&amp;改进动画心率检测类封装完成后，我又剥离出显示心跳波形的部分，封装成一个MTHeartBeatsWaveView，使用的时候只要将动画View赋给MTHeartBeatsCapture作为delegate，该view上就能获取到特征值数据并进行显示。 动画改进：在测试的过程中，我发现波形动画显示的波形不太理想，View的大小是初始化的时候就确定的，但是心跳波动的幅度变化是比较大的，有时候一马平川，堪比飞机场，有时候波澜壮阔，直接超出View的范围。因此我对动画的显示做了一个改进：能够根据当前波形的范围，计算出合适的缩放比，对心跳曲线的Y坐标进行动态的缩放，使它的上下幅度适合当前的View。这个改进大大提高了用户体验。 五、优化我们可以看到，先前得到的曲线已经能较好地反映出心脏的搏动，但是现在进行心率的计算还是存在一定的误检率。上图中展示的清晰的心跳曲线，实际上是比较理想的时候，测试中会发现，采样得到的数据经常存在较大的噪声和扰动，导致心率计算中经常会有波峰的误判。因此，我在以下两方面做了优化，来提高心率检测的准确度。 1、在预处理环节进行滤波 分析一下心率曲线里的噪声，我们会发现，噪声中含有一些高频噪声，这部分噪声可能是手指的细微抖动造成的，也可能是相机产生的一些噪点。因此，我找到了一个简易的实时的带通滤波器，对之前我们采样获得到的H值进行处理，滤除了一部分高频和低频的噪声。 在经过滤波器的处理之后，我们得到的曲线就更加平滑啦。 2、参考TP-Psola算法，排除伪波峰经过滤波器的处理之后，我们会发现，在每个心跳周期中，总会有一个小波峰，因为它不是真正的波峰，因此我称它为“伪波峰”，这个伪波峰非常明显，有时也会干扰到我们心率的检测，被算法误判为心跳波峰，导致心率直接翻倍。 这个伪波峰出现是因为，除了外部的噪声之外，心脏本身的跳动周期中也会出现许多的“杂波”。我们来看一次心跳的完整过程。 上图是一次心跳周期中，心脏的状态变化以及对应产生的波段。可以看到，在心脏收缩前后，人体也会有电信号刺激心脏舒张，这在心电图上会表现出若干次的波动。而血压也会有相应的变化，我们检测到的数据的波动就是这样形成的。 因此，这个伪波峰的形成是无法避免的，现有的通过阈值来判断波峰的方法很容易被欺骗，还是要考虑算法的改进，因此我又想到了快速傅里叶变换。 由于我对信号处理知之甚少，我看了两天的快速傅里叶，还是没有进展。于是我请教了部门里的前辈们，大家非常热情，推荐了不少方案和资料。其中一位实验室音频处理的博伟学长，碰巧在新人入职培训时和我分到了同一组，我就趁着闲暇的时候请教了他一些相关的问题。他觉得心率的波形比较简单，没必要用快速傅里叶变换，并且向我推荐了基音检测算法。 简单地说，这个算法会标注出可能的波峰，然后通过动态规划排除掉伪波峰，就能得到真正的波峰啦。我根据这个算法的思路，实现了一个简化版的伪波峰排除算法。经过改进后的心率检测，经测试准确度达到了和Apple watch差不多的程度。（自我感觉良好😂，求轻喷~~） 实时波峰检测我还希望提供一个实时的心跳动画，因此我还实现了一个实时的波峰检测。这样每次检测到一个波峰之后，就可以立刻通知delegate或者block，在界面上做出动画。 歇-后-语 由于这一章节是歇了一阵子之后才写的，因此我把它叫做——歇后语。 这个心率检测的项目前后一共做了三个礼拜左右，虽然第一个Demo用了三四天就完成，但是后续的封装和优化却用了两个星期的时间，嗯，感触颇深。。。 从最开始的incredible，到最后的好意思说堪比Apple Watch，真的是一个很有成就感的过程。虽然期间遇到了不少困难，甚至有那么一两次觉得自己真的无解了，但到最后总能熬过去，山重水复疑无路，柳暗花明又一村。真的忍不住要念诗了，感觉很充实，很开心。 在做这个项目的过程中，我也得到了许多人的帮助。部门里的各位前辈、同事，在看到我的提问之后，非常热情地向我提供意见和资料。希望这篇博客会对大家有所帮助。谢谢大家~ 【更新于2016/8/10】 经coderMoe童鞋指出，文中 [三、2.降低采样率] 提到的 “定理” 正式的名称为“奈奎斯特采样定理”。 感谢这段时间以来，大家的鼓励和支持，前阵子我写这篇文章的时候，是万万没有想到会得到这么多人的关注的，实在是受宠若惊。有很多人详细地阅读了这篇博客，并且提出了重要的意见，甚至还有几位客官打赏了我（但是简书取现要满100RMB才行，所以目前我还无法享用这笔增肥基金🙊哈哈），真的很感谢你们。 我当时写这篇博客也花了不少时间，只怪我语文没学好，在言辞表达上、逻辑结构上，没能做得更好，大家如果有什么意见建议、或者不同的见解，希望能不吝赐教~~大家的关注和交流会让我更有动力分享博客，要知道，写作对我这种工科生而言，真的是，“体力活”。😂 有想要进一步关注我的朋友，可以收藏一下我正在搭建的博客，域名正在备案中，不过博客系统是已经搭起来了，有兴趣的朋友请移步：punmy.cn😋 另外，关于许多朋友非常关心的开源的问题，这两天上班比较忙，但是我会在近期确定是否开源，届时会通过简书更新，感谢关注！ 【更新于2016/8/18】感谢大家的厚爱，收到Leader的回复，这个项目暂时不开源，不好意思。 但是大家如果有什么问题，欢迎继续和我探讨！😊 【更新于2016/8/19】 另外，有朋友指出，iPhone相机支持的原始数据格式有三种，一种是文中提到的BGRA，另两种似乎是YUV的格式，我对这方面不太了解，感谢提出，详情请看文档。 【更新于2018/4/8】前段时间重新在 Github 上搭建了自己的博客，最近才有空把之前简书上的博客搬了过来，想开始维护自己的博客了。 The End. 延伸阅读 光电容积脉搏波描记法”https://en.wikipedia.org/wiki/Photoplethysmogram 滤波：http://blog.csdn.net/shengzhadon/article/details/46803401 Accelerate.framework：DSP处理框架（vDSP）：http://stackoverflow.com/questions/3398753/using-the-apple-fft-and-accelerate-framework core Graphics画图：http://www.mamicode.com/info-detail-841887.html 心率检测论文：http://www.doc88.com/p-0307201762779.html 通过脸部识别心率：http://people.csail.mit.edu/mrub/vidmag/ 外部引用 [0]: 写出“前情提要”的时候，脑子里蹦出的是：previously on marvel agents of shield😂 [1]: 引用自维基百科，由Kalumet - selbst erstellt = 自己的作品，CC BY-SA 3.0，https://commons.wiki/media.org/w/index.php?curid=438152 [2]: 引用自维基百科，由Derivative: Hazmat2Original: Hank van Helvete - 此档案源起于以下档案或由以下档案加以编辑而成: EKG Complex en.svg，CC BY-SA 3.0，https://commons.wiki/media.org/w/index.php?curid=31447770 [5]:引用自维基百科，由(3ucky(3all - Uploaded to en:File:HSV cone.png first (see associated log) by (3ucky(3all; then transfered to Commons by Moongateclimber.，CC BY-SA 3.0，https://commons.wiki/media.org/w/index.php?curid=943857","categories":[{"name":"Code","slug":"Code","permalink":"http://punmy.cn/categories/Code/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://punmy.cn/tags/iOS/"},{"name":"Camera","slug":"Camera","permalink":"http://punmy.cn/tags/Camera/"},{"name":"Article","slug":"Article","permalink":"http://punmy.cn/tags/Article/"}]}]}